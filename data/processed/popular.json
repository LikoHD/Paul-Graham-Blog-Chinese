{
  "title": "Being Popular",
  "title_zh": "[待翻译] Being Popular",
  "url": "https://www.paulgraham.com/popular.html",
  "filename": "popular.html",
  "date": "2001-05-01",
  "id": 228,
  "content": {
    "success": true,
    "paragraphs": [
      "May 2001(This article was written as a kind of business plan for a new language. So it is missing (because it takes for granted) the most important feature of a good programming language: very powerful abstractions.)A friend of mine once told an eminent operating systems expert that he wanted to design a really good programming language.",
      "The expert told him that it would be a waste of time, that programming languages don't become popular or unpopular based on their merits, and so no matter how good his language was, no one would use it.",
      "At least, that was what had happened to the language he had designed.What does make a language popular? Do popular languages deserve their popularity? Is it worth trying to define a good programming language?",
      "How would you do it?I think the answers to these questions can be found by looking at hackers, and learning what they want. Programming languages are for hackers, and a programming language is good as a programming language (rather than, say, an exercise in denotational semantics or compiler design) if and only if hackers like it.1 The Mechanics of PopularityIt's true, certainly, that most people don't choose programming languages simply based on their merits.",
      "Most programmers are told what language to use by someone else. And yet I think the effect of such external factors on the popularity of programming languages is not as great as it's sometimes thought to be.",
      "I think a bigger problem is that a hacker's idea of a good programming language is not the same as most language designers'.Between the two, the hacker's opinion is the one that matters. Programming languages are not theorems.",
      "They're tools, designed for people, and they have to be designed to suit human strengths and weaknesses as much as shoes have to be designed for human feet. If a shoe pinches when you put it on, it's a bad shoe, however elegant it may be as a piece of sculpture.It may be that the majority of programmers can't tell a good language from a bad one.",
      "But that's no different with any other tool. It doesn't mean that it's a waste of time to try designing a good language. Expert hackers can tell a good language when they see one, and they'll use it.",
      "Expert hackers are a tiny minority, admittedly, but that tiny minority write all the good software, and their influence is such that the rest of the programmers will tend to use whatever language they use.",
      "Often, indeed, it is not merely influence but command: often the expert hackers are the very people who, as their bosses or faculty advisors, tell the other programmers what language to use.The opinion of expert hackers is not the only force that determines the relative popularity of programming languages — legacy software (Cobol) and hype (Ada, Java) also play a role — but I think it is the most powerful force over the long term.",
      "Given an initial critical mass and enough time, a programming language probably becomes about as popular as it deserves to be. And popularity further separates good languages from bad ones, because feedback from real live users always leads to improvements.",
      "Look at how much any popular language has changed during its life. Perl and Fortran are extreme cases, but even Lisp has changed a lot. Lisp 1.5 didn't have macros, for example; these evolved later, after hackers at MIT had spent a couple years using Lisp to write real programs.",
      "[1]So whether or not a language has to be good to be popular, I think a language has to be popular to be good. And it has to stay popular to stay good. The state of the art in programming languages doesn't stand still.",
      "And yet the Lisps we have today are still pretty much what they had at MIT in the mid-1980s, because that's the last time Lisp had a sufficiently large and demanding user base.Of course, hackers have to know about a language before they can use it.",
      "How are they to hear? From other hackers. But there has to be some initial group of hackers using the language for others even to hear about it. I wonder how large this group has to be; how many users make a critical mass?",
      "Off the top of my head, I'd say twenty. If a language had twenty separate users, meaning twenty users who decided on their own to use it, I'd consider it to be real.Getting there can't be easy. I would not be surprised if it is harder to get from zero to twenty than from twenty to a thousand.",
      "The best way to get those initial twenty users is probably to use a trojan horse: to give people an application they want, which happens to be written in the new language.2 External FactorsLet's start by acknowledging one external factor that does affect the popularity of a programming language.",
      "To become popular, a programming language has to be the scripting language of a popular system. Fortran and Cobol were the scripting languages of early IBM mainframes. C was the scripting language of Unix, and so, later, was Perl.",
      "Tcl is the scripting language of Tk. Java and Javascript are intended to be the scripting languages of web browsers.Lisp is not a massively popular language because it is not the scripting language of a massively popular system.",
      "What popularity it retains dates back to the 1960s and 1970s, when it was the scripting language of MIT. A lot of the great programmers of the day were associated with MIT at some point. And in the early 1970s, before C, MIT's dialect of Lisp, called MacLisp, was one of the only programming languages a serious hacker would want to use.Today Lisp is the scripting language of two moderately popular systems, Emacs and Autocad, and for that reason I suspect that most of the Lisp programming done today is done in Emacs Lisp or AutoLisp.Programming languages don't exist in isolation.",
      "To hack is a transitive verb — hackers are usually hacking something — and in practice languages are judged relative to whatever they're used to hack. So if you want to design a popular language, you either have to supply more than a language, or you have to design your language to replace the scripting language of some existing system.Common Lisp is unpopular partly because it's an orphan.",
      "It did originally come with a system to hack: the Lisp Machine. But Lisp Machines (along with parallel computers) were steamrollered by the increasing power of general purpose processors in the 1980s.",
      "Common Lisp might have remained popular if it had been a good scripting language for Unix. It is, alas, an atrociously bad one.One way to describe this situation is to say that a language isn't judged on its own merits.",
      "Another view is that a programming language really isn't a programming language unless it's also the scripting language of something. This only seems unfair if it comes as a surprise. I think it's no more unfair than expecting a programming language to have, say, an implementation.",
      "It's just part of what a programming language is.A programming language does need a good implementation, of course, and this must be free. Companies will pay for software, but individual hackers won't, and it's the hackers you need to attract.A language also needs to have a book about it.",
      "The book should be thin, well-written, and full of good examples. K&R is the ideal here. At the moment I'd almost say that a language has to have a book published by O'Reilly. That's becoming the test of mattering to hackers.There should be online documentation as well.",
      "In fact, the book can start as online documentation. But I don't think that physical books are outmoded yet. Their format is convenient, and the de facto censorship imposed by publishers is a useful if imperfect filter.",
      "Bookstores are one of the most important places for learning about new languages.3 BrevityGiven that you can supply the three things any language needs — a free implementation, a book, and something to hack — how do you make a language that hackers will like?One thing hackers like is brevity.",
      "Hackers are lazy, in the same way that mathematicians and modernist architects are lazy: they hate anything extraneous. It would not be far from the truth to say that a hacker about to write a program decides what language to use, at least subconsciously, based on the total number of characters he'll have to type.",
      "If this isn't precisely how hackers think, a language designer would do well to act as if it were.It is a mistake to try to baby the user with long-winded expressions that are meant to resemble English.",
      "Cobol is notorious for this flaw. A hacker would consider being asked to writeadd x to y giving zinstead ofz = x+yas something between an insult to his intelligence and a sin against God.It has sometimes been said that Lisp should use first and rest instead of car and cdr, because it would make programs easier to read.",
      "Maybe for the first couple hours. But a hacker can learn quickly enough that car means the first element of a list and cdr means the rest. Using first and rest means 50% more typing. And they are also different lengths, meaning that the arguments won't line up when they're called, as car and cdr often are, in successive lines.",
      "I've found that it matters a lot how code lines up on the page. I can barely read Lisp code when it is set in a variable-width font, and friends say this is true for other languages too.Brevity is one place where strongly typed languages lose.",
      "All other things being equal, no one wants to begin a program with a bunch of declarations. Anything that can be implicit, should be.The individual tokens should be short as well. Perl and Common Lisp occupy opposite poles on this question.",
      "Perl programs can be almost cryptically dense, while the names of built-in Common Lisp operators are comically long. The designers of Common Lisp probably expected users to have text editors that would type these long names for them.",
      "But the cost of a long name is not just the cost of typing it. There is also the cost of reading it, and the cost of the space it takes up on your screen.4 HackabilityThere is one thing more important than brevity to a hacker: being able to do what you want.",
      "In the history of programming languages a surprising amount of effort has gone into preventing programmers from doing things considered to be improper. This is a dangerously presumptuous plan. How can the language designer know what the programmer is going to need to do?",
      "I think language designers would do better to consider their target user to be a genius who will need to do things they never anticipated, rather than a bumbler who needs to be protected from himself.",
      "The bumbler will shoot himself in the foot anyway. You may save him from referring to variables in another package, but you can't save him from writing a badly designed program to solve the wrong problem, and taking forever to do it.Good programmers often want to do dangerous and unsavory things.",
      "By unsavory I mean things that go behind whatever semantic facade the language is trying to present: getting hold of the internal representation of some high-level abstraction, for example. Hackers like to hack, and hacking means getting inside things and second guessing the original designer.Let yourself be second guessed.",
      "When you make any tool, people use it in ways you didn't intend, and this is especially true of a highly articulated tool like a programming language. Many a hacker will want to tweak your semantic model in a way that you never imagined.",
      "I say, let them; give the programmer access to as much internal stuff as you can without endangering runtime systems like the garbage collector.In Common Lisp I have often wanted to iterate through the fields of a struct — to comb out references to a deleted object, for example, or find fields that are uninitialized.",
      "I know the structs are just vectors underneath. And yet I can't write a general purpose function that I can call on any struct. I can only access the fields by name, because that's what a struct is supposed to mean.A hacker may only want to subvert the intended model of things once or twice in a big program.",
      "But what a difference it makes to be able to. And it may be more than a question of just solving a problem. There is a kind of pleasure here too. Hackers share the surgeon's secret pleasure in poking about in gross innards, the teenager's secret pleasure in popping zits.",
      "[2] For boys, at least, certain kinds of horrors are fascinating. Maxim magazine publishes an annual volume of photographs, containing a mix of pin-ups and grisly accidents. They know their audience.Historically, Lisp has been good at letting hackers have their way.",
      "The political correctness of Common Lisp is an aberration. Early Lisps let you get your hands on everything. A good deal of that spirit is, fortunately, preserved in macros. What a wonderful thing, to be able to make arbitrary transformations on the source code.Classic macros are a real hacker's tool — simple, powerful, and dangerous.",
      "It's so easy to understand what they do: you call a function on the macro's arguments, and whatever it returns gets inserted in place of the macro call. Hygienic macros embody the opposite principle.",
      "They try to protect you from understanding what they're doing. I have never heard hygienic macros explained in one sentence. And they are a classic example of the dangers of deciding what programmers are allowed to want.",
      "Hygienic macros are intended to protect me from variable capture, among other things, but variable capture is exactly what I want in some macros.A really good language should be both clean and dirty: cleanly designed, with a small core of well understood and highly orthogonal operators, but dirty in the sense that it lets hackers have their way with it.",
      "C is like this. So were the early Lisps. A real hacker's language will always have a slightly raffish character.A good programming language should have features that make the kind of people who use the phrase \"software engineering\" shake their heads disapprovingly.",
      "At the other end of the continuum are languages like Ada and Pascal, models of propriety that are good for teaching and not much else.5 Throwaway ProgramsTo be attractive to hackers, a language must be good for writing the kinds of programs they want to write.",
      "And that means, perhaps surprisingly, that it has to be good for writing throwaway programs.A throwaway program is a program you write quickly for some limited task: a program to automate some system administration task, or generate test data for a simulation, or convert data from one format to another.",
      "The surprising thing about throwaway programs is that, like the \"temporary\" buildings built at so many American universities during World War II, they often don't get thrown away. Many evolve into real programs, with real features and real users.I have a hunch that the best big programs begin life this way, rather than being designed big from the start, like the Hoover Dam.",
      "It's terrifying to build something big from scratch. When people take on a project that's too big, they become overwhelmed. The project either gets bogged down, or the result is sterile and wooden: a shopping mall rather than a real downtown, Brasilia rather than Rome, Ada rather than C.Another way to get a big program is to start with a throwaway program and keep improving it.",
      "This approach is less daunting, and the design of the program benefits from evolution. I think, if one looked, that this would turn out to be the way most big programs were developed. And those that did evolve this way are probably still written in whatever language they were first written in, because it's rare for a program to be ported, except for political reasons.",
      "And so, paradoxically, if you want to make a language that is used for big systems, you have to make it good for writing throwaway programs, because that's where big systems come from.Perl is a striking example of this idea.",
      "It was not only designed for writing throwaway programs, but was pretty much a throwaway program itself. Perl began life as a collection of utilities for generating reports, and only evolved into a programming language as the throwaway programs people wrote in it grew larger.",
      "It was not until Perl 5 (if then) that the language was suitable for writing serious programs, and yet it was already massively popular.What makes a language good for throwaway programs? To start with, it must be readily available.",
      "A throwaway program is something that you expect to write in an hour. So the language probably must already be installed on the computer you're using. It can't be something you have to install before you use it.",
      "It has to be there. C was there because it came with the operating system. Perl was there because it was originally a tool for system administrators, and yours had already installed it.Being available means more than being installed, though.",
      "An interactive language, with a command-line interface, is more available than one that you have to compile and run separately. A popular programming language should be interactive, and start up fast.Another thing you want in a throwaway program is brevity.",
      "Brevity is always attractive to hackers, and never more so than in a program they expect to turn out in an hour.6 LibrariesOf course the ultimate in brevity is to have the program already written for you, and merely to call it.",
      "And this brings us to what I think will be an increasingly important feature of programming languages: library functions. Perl wins because it has large libraries for manipulating strings. This class of library functions are especially important for throwaway programs, which are often originally written for converting or extracting data.",
      "Many Perl programs probably begin as just a couple library calls stuck together.I think a lot of the advances that happen in programming languages in the next fifty years will have to do with library functions.",
      "I think future programming languages will have libraries that are as carefully designed as the core language. Programming language design will not be about whether to make your language strongly or weakly typed, or object oriented, or functional, or whatever, but about how to design great libraries.",
      "The kind of language designers who like to think about how to design type systems may shudder at this. It's almost like writing applications! Too bad. Languages are for programmers, and libraries are what programmers need.It's hard to design good libraries.",
      "It's not simply a matter of writing a lot of code. Once the libraries get too big, it can sometimes take longer to find the function you need than to write the code yourself. Libraries need to be designed using a small set of orthogonal operators, just like the core language.",
      "It ought to be possible for the programmer to guess what library call will do what he needs.Libraries are one place Common Lisp falls short. There are only rudimentary libraries for manipulating strings, and almost none for talking to the operating system.",
      "For historical reasons, Common Lisp tries to pretend that the OS doesn't exist. And because you can't talk to the OS, you're unlikely to be able to write a serious program using only the built-in operators in Common Lisp.",
      "You have to use some implementation-specific hacks as well, and in practice these tend not to give you everything you want. Hackers would think a lot more highly of Lisp if Common Lisp had powerful string libraries and good OS support.7 SyntaxCould a language with Lisp's syntax, or more precisely, lack of syntax, ever become popular?",
      "I don't know the answer to this question. I do think that syntax is not the main reason Lisp isn't currently popular. Common Lisp has worse problems than unfamiliar syntax. I know several programmers who are comfortable with prefix syntax and yet use Perl by default, because it has powerful string libraries and can talk to the os.There are two possible problems with prefix notation: that it is unfamiliar to programmers, and that it is not dense enough.",
      "The conventional wisdom in the Lisp world is that the first problem is the real one. I'm not so sure. Yes, prefix notation makes ordinary programmers panic. But I don't think ordinary programmers' opinions matter.",
      "Languages become popular or unpopular based on what expert hackers think of them, and I think expert hackers might be able to deal with prefix notation. Perl syntax can be pretty incomprehensible, but that has not stood in the way of Perl's popularity.",
      "If anything it may have helped foster a Perl cult.A more serious problem is the diffuseness of prefix notation. For expert hackers, that really is a problem. No one wants to write (aref a x y) when they could write a[x,y].In this particular case there is a way to finesse our way out of the problem.",
      "If we treat data structures as if they were functions on indexes, we could write (a x y) instead, which is even shorter than the Perl form. Similar tricks may shorten other types of expressions.We can get rid of (or make optional) a lot of parentheses by making indentation significant.",
      "That's how programmers read code anyway: when indentation says one thing and delimiters say another, we go by the indentation. Treating indentation as significant would eliminate this common source of bugs as well as making programs shorter.Sometimes infix syntax is easier to read.",
      "This is especially true for math expressions. I've used Lisp my whole programming life and I still don't find prefix math expressions natural. And yet it is convenient, especially when you're generating code, to have operators that take any number of arguments.",
      "So if we do have infix syntax, it should probably be implemented as some kind of read-macro.I don't think we should be religiously opposed to introducing syntax into Lisp, as long as it translates in a well-understood way into underlying s-expressions.",
      "There is already a good deal of syntax in Lisp. It's not necessarily bad to introduce more, as long as no one is forced to use it. In Common Lisp, some delimiters are reserved for the language, suggesting that at least some of the designers intended to have more syntax in the future.One of the most egregiously unlispy pieces of syntax in Common Lisp occurs in format strings; format is a language in its own right, and that language is not Lisp.",
      "If there were a plan for introducing more syntax into Lisp, format specifiers might be able to be included in it. It would be a good thing if macros could generate format specifiers the way they generate any other kind of code.An eminent Lisp hacker told me that his copy of CLTL falls open to the section format.",
      "Mine too. This probably indicates room for improvement. It may also mean that programs do a lot of I/O.8 EfficiencyA good language, as everyone knows, should generate fast code. But in practice I don't think fast code comes primarily from things you do in the design of the language.",
      "As Knuth pointed out long ago, speed only matters in certain critical bottlenecks. And as many programmers have observed since, one is very often mistaken about where these bottlenecks are.So, in practice, the way to get fast code is to have a very good profiler, rather than by, say, making the language strongly typed.",
      "You don't need to know the type of every argument in every call in the program. You do need to be able to declare the types of arguments in the bottlenecks. And even more, you need to be able to find out where the bottlenecks are.One complaint people have had with Lisp is that it's hard to tell what's expensive.",
      "This might be true. It might also be inevitable, if you want to have a very abstract language. And in any case I think good profiling would go a long way toward fixing the problem: you'd soon learn what was expensive.Part of the problem here is social.",
      "Language designers like to write fast compilers. That's how they measure their skill. They think of the profiler as an add-on, at best. But in practice a good profiler may do more to improve the speed of actual programs written in the language than a compiler that generates fast code.",
      "Here, again, language designers are somewhat out of touch with their users. They do a really good job of solving slightly the wrong problem.It might be a good idea to have an active profiler — to push performance data to the programmer instead of waiting for him to come asking for it.",
      "For example, the editor could display bottlenecks in red when the programmer edits the source code. Another approach would be to somehow represent what's happening in running programs. This would be an especially big win in server-based applications, where you have lots of running programs to look at.",
      "An active profiler could show graphically what's happening in memory as a program's running, or even make sounds that tell what's happening.Sound is a good cue to problems. In one place I worked, we had a big board of dials showing what was happening to our web servers.",
      "The hands were moved by little servomotors that made a slight noise when they turned. I couldn't see the board from my desk, but I found that I could tell immediately, by the sound, when there was a problem with a server.It might even be possible to write a profiler that would automatically detect inefficient algorithms.",
      "I would not be surprised if certain patterns of memory access turned out to be sure signs of bad algorithms. If there were a little guy running around inside the computer executing our programs, he would probably have as long and plaintive a tale to tell about his job as a federal government employee.",
      "I often have a feeling that I'm sending the processor on a lot of wild goose chases, but I've never had a good way to look at what it's doing.A number of Lisps now compile into byte code, which is then executed by an interpreter.",
      "This is usually done to make the implementation easier to port, but it could be a useful language feature. It might be a good idea to make the byte code an official part of the language, and to allow programmers to use inline byte code in bottlenecks.",
      "Then such optimizations would be portable too.The nature of speed, as perceived by the end-user, may be changing. With the rise of server-based applications, more and more programs may turn out to be i/o-bound.",
      "It will be worth making i/o fast. The language can help with straightforward measures like simple, fast, formatted output functions, and also with deep structural changes like caching and persistent objects.Users are interested in response time.",
      "But another kind of efficiency will be increasingly important: the number of simultaneous users you can support per processor. Many of the interesting applications written in the near future will be server-based, and the number of users per server is the critical question for anyone hosting such applications.",
      "In the capital cost of a business offering a server-based application, this is the divisor.For years, efficiency hasn't mattered much in most end-user applications. Developers have been able to assume that each user would have an increasingly powerful processor sitting on their desk.",
      "And by Parkinson's Law, software has expanded to use the resources available. That will change with server-based applications. In that world, the hardware and software will be supplied together. For companies that offer server-based applications, it will make a very big difference to the bottom line how many users they can support per server.In some applications, the processor will be the limiting factor, and execution speed will be the most important thing to optimize.",
      "But often memory will be the limit; the number of simultaneous users will be determined by the amount of memory you need for each user's data. The language can help here too. Good support for threads will enable all the users to share a single heap.",
      "It may also help to have persistent objects and/or language level support for lazy loading.9 TimeThe last ingredient a popular language needs is time. No one wants to write programs in a language that might go away, as so many programming languages do.",
      "So most hackers will tend to wait until a language has been around for a couple years before even considering using it.Inventors of wonderful new things are often surprised to discover this, but you need time to get any message through to people.",
      "A friend of mine rarely does anything the first time someone asks him. He knows that people sometimes ask for things that they turn out not to want. To avoid wasting his time, he waits till the third or fourth time he's asked to do something; by then, whoever's asking him may be fairly annoyed, but at least they probably really do want whatever they're asking for.Most people have learned to do a similar sort of filtering on new things they hear about.",
      "They don't even start paying attention until they've heard about something ten times. They're perfectly justified: the majority of hot new whatevers do turn out to be a waste of time, and eventually go away.",
      "By delaying learning VRML, I avoided having to learn it at all.So anyone who invents something new has to expect to keep repeating their message for years before people will start to get it. We wrote what was, as far as I know, the first web-server based application, and it took us years to get it through to people that it didn't have to be downloaded.",
      "It wasn't that they were stupid. They just had us tuned out.The good news is, simple repetition solves the problem. All you have to do is keep telling your story, and eventually people will start to hear.",
      "It's not when people notice you're there that they pay attention; it's when they notice you're still there.It's just as well that it usually takes a while to gain momentum. Most technologies evolve a good deal even after they're first launched — programming languages especially.",
      "Nothing could be better, for a new techology, than a few years of being used only by a small number of early adopters. Early adopters are sophisticated and demanding, and quickly flush out whatever flaws remain in your technology.",
      "When you only have a few users you can be in close contact with all of them. And early adopters are forgiving when you improve your system, even if this causes some breakage.There are two ways new technology gets introduced: the organic growth method, and the big bang method.",
      "The organic growth method is exemplified by the classic seat-of-the-pants underfunded garage startup. A couple guys, working in obscurity, develop some new technology. They launch it with no marketing and initially have only a few (fanatically devoted) users.",
      "They continue to improve the technology, and meanwhile their user base grows by word of mouth. Before they know it, they're big.The other approach, the big bang method, is exemplified by the VC-backed, heavily marketed startup.",
      "They rush to develop a product, launch it with great publicity, and immediately (they hope) have a large user base.Generally, the garage guys envy the big bang guys. The big bang guys are smooth and confident and respected by the VCs.",
      "They can afford the best of everything, and the PR campaign surrounding the launch has the side effect of making them celebrities. The organic growth guys, sitting in their garage, feel poor and unloved.",
      "And yet I think they are often mistaken to feel sorry for themselves. Organic growth seems to yield better technology and richer founders than the big bang method. If you look at the dominant technologies today, you'll find that most of them grew organically.This pattern doesn't only apply to companies.",
      "You see it in sponsored research too. Multics and Common Lisp were big-bang projects, and Unix and MacLisp were organic growth projects.10 Redesign\"The best writing is rewriting,\" wrote E. B. White. Every good writer knows this, and it's true for software too.",
      "The most important part of design is redesign. Programming languages, especially, don't get redesigned enough.To write good software you must simultaneously keep two opposing ideas in your head. You need the young hacker's naive faith in his abilities, and at the same time the veteran's skepticism.",
      "You have to be able to think how hard can it be? with one half of your brain while thinking it will never work with the other.The trick is to realize that there's no real contradiction here. You want to be optimistic and skeptical about two different things.",
      "You have to be optimistic about the possibility of solving the problem, but skeptical about the value of whatever solution you've got so far.People who do good work often think that whatever they're working on is no good.",
      "Others see what they've done and are full of wonder, but the creator is full of worry. This pattern is no coincidence: it is the worry that made the work good.If you can keep hope and worry balanced, they will drive a project forward the same way your two legs drive a bicycle forward.",
      "In the first phase of the two-cycle innovation engine, you work furiously on some problem, inspired by your confidence that you'll be able to solve it. In the second phase, you look at what you've done in the cold light of morning, and see all its flaws very clearly.",
      "But as long as your critical spirit doesn't outweigh your hope, you'll be able to look at your admittedly incomplete system, and think, how hard can it be to get the rest of the way?, thereby continuing the cycle.It's tricky to keep the two forces balanced.",
      "In young hackers, optimism predominates. They produce something, are convinced it's great, and never improve it. In old hackers, skepticism predominates, and they won't even dare to take on ambitious projects.Anything you can do to keep the redesign cycle going is good.",
      "Prose can be rewritten over and over until you're happy with it. But software, as a rule, doesn't get redesigned enough. Prose has readers, but software has users. If a writer rewrites an essay, people who read the old version are unlikely to complain that their thoughts have been broken by some newly introduced incompatibility.Users are a double-edged sword.",
      "They can help you improve your language, but they can also deter you from improving it. So choose your users carefully, and be slow to grow their number. Having users is like optimization: the wise course is to delay it.",
      "Also, as a general rule, you can at any given time get away with changing more than you think. Introducing change is like pulling off a bandage: the pain is a memory almost as soon as you feel it.Everyone knows that it's not a good idea to have a language designed by a committee.",
      "Committees yield bad design. But I think the worst danger of committees is that they interfere with redesign. It is so much work to introduce changes that no one wants to bother. Whatever a committee decides tends to stay that way, even if most of the members don't like it.Even a committee of two gets in the way of redesign.",
      "This happens particularly in the interfaces between pieces of software written by two different people. To change the interface both have to agree to change it at once. And so interfaces tend not to change at all, which is a problem because they tend to be one of the most ad hoc parts of any system.One solution here might be to design systems so that interfaces are horizontal instead of vertical — so that modules are always vertically stacked strata of abstraction.",
      "Then the interface will tend to be owned by one of them. The lower of two levels will either be a language in which the upper is written, in which case the lower level will own the interface, or it will be a slave, in which case the interface can be dictated by the upper level.11 LispWhat all this implies is that there is hope for a new Lisp.",
      "There is hope for any language that gives hackers what they want, including Lisp. I think we may have made a mistake in thinking that hackers are turned off by Lisp's strangeness. This comforting illusion may have prevented us from seeing the real problem with Lisp, or at least Common Lisp, which is that it sucks for doing what hackers want to do.",
      "A hacker's language needs powerful libraries and something to hack. Common Lisp has neither. A hacker's language is terse and hackable. Common Lisp is not.The good news is, it's not Lisp that sucks, but Common Lisp.",
      "If we can develop a new Lisp that is a real hacker's language, I think hackers will use it. They will use whatever language does the job. All we have to do is make sure this new Lisp does some important job better than other languages.History offers some encouragement.",
      "Over time, successive new programming languages have taken more and more features from Lisp. There is no longer much left to copy before the language you've made is Lisp. The latest hot language, Python, is a watered-down Lisp with infix syntax and no macros.",
      "A new Lisp would be a natural step in this progression.I sometimes think that it would be a good marketing trick to call it an improved version of Python. That sounds hipper than Lisp. To many people, Lisp is a slow AI language with a lot of parentheses.",
      "Fritz Kunze's official biography carefully avoids mentioning the L-word. But my guess is that we shouldn't be afraid to call the new Lisp Lisp. Lisp still has a lot of latent respect among the very best hackers — the ones who took 6.001 and understood it, for example.",
      "And those are the users you need to win.In \"How to Become a Hacker,\" Eric Raymond describes Lisp as something like Latin or Greek — a language you should learn as an intellectual exercise, even though you won't actually use it: Lisp is worth learning for the profound enlightenment experience you will have when you finally get it; that experience will make you a better programmer for the rest of your days, even if you never actually use Lisp itself a lot.",
      "If I didn't know Lisp, reading this would set me asking questions. A language that would make me a better programmer, if it means anything at all, means a language that would be better for programming.",
      "And that is in fact the implication of what Eric is saying.As long as that idea is still floating around, I think hackers will be receptive enough to a new Lisp, even if it is called Lisp. But this Lisp must be a hacker's language, like the classic Lisps of the 1970s.",
      "It must be terse, simple, and hackable. And it must have powerful libraries for doing what hackers want to do now.In the matter of libraries I think there is room to beat languages like Perl and Python at their own game.",
      "A lot of the new applications that will need to be written in the coming years will be server-based applications. There's no reason a new Lisp shouldn't have string libraries as good as Perl, and if this new Lisp also had powerful libraries for server-based applications, it could be very popular.",
      "Real hackers won't turn up their noses at a new tool that will let them solve hard problems with a few library calls. Remember, hackers are lazy.It could be an even bigger win to have core language support for server-based applications.",
      "For example, explicit support for programs with multiple users, or data ownership at the level of type tags.Server-based applications also give us the answer to the question of what this new Lisp will be used to hack.",
      "It would not hurt to make Lisp better as a scripting language for Unix. (It would be hard to make it worse.) But I think there are areas where existing languages would be easier to beat. I think it might be better to follow the model of Tcl, and supply the Lisp together with a complete system for supporting server-based applications.",
      "Lisp is a natural fit for server-based applications. Lexical closures provide a way to get the effect of subroutines when the ui is just a series of web pages. S-expressions map nicely onto html, and macros are good at generating it.",
      "There need to be better tools for writing server-based applications, and there needs to be a new Lisp, and the two would work very well together.12 The Dream LanguageBy way of summary, let's try describing the hacker's dream language.",
      "The dream language is beautiful, clean, and terse. It has an interactive toplevel that starts up fast. You can write programs to solve common problems with very little code. Nearly all the code in any program you write is code that's specific to your application.",
      "Everything else has been done for you.The syntax of the language is brief to a fault. You never have to type an unnecessary character, or even to use the shift key much.Using big abstractions you can write the first version of a program very quickly.",
      "Later, when you want to optimize, there's a really good profiler that tells you where to focus your attention. You can make inner loops blindingly fast, even writing inline byte code if you need to.There are lots of good examples to learn from, and the language is intuitive enough that you can learn how to use it from examples in a couple minutes.",
      "You don't need to look in the manual much. The manual is thin, and has few warnings and qualifications.The language has a small core, and powerful, highly orthogonal libraries that are as carefully designed as the core language.",
      "The libraries all work well together; everything in the language fits together like the parts in a fine camera. Nothing is deprecated, or retained for compatibility. The source code of all the libraries is readily available.",
      "It's easy to talk to the operating system and to applications written in other languages.The language is built in layers. The higher-level abstractions are built in a very transparent way out of lower-level abstractions, which you can get hold of if you want.Nothing is hidden from you that doesn't absolutely have to be.",
      "The language offers abstractions only as a way of saving you work, rather than as a way of telling you what to do. In fact, the language encourages you to be an equal participant in its design. You can change everything about it, including even its syntax, and anything you write has, as much as possible, the same status as what comes predefined.Notes[1] Macros very close to the modern idea were proposed by Timothy Hart in 1964, two years after Lisp 1.5 was released.",
      "What was missing, initially, were ways to avoid variable capture and multiple evaluation; Hart's examples are subject to both.[2] In When the Air Hits Your Brain, neurosurgeon Frank Vertosick recounts a conversation in which his chief resident, Gary, talks about the difference between surgeons and internists (\"fleas\"): Gary and I ordered a large pizza and found an open booth.",
      "The chief lit a cigarette. \"Look at those goddamn fleas, jabbering about some disease they'll see once in their lifetimes. That's the trouble with fleas, they only like the bizarre stuff. They hate their bread and butter cases.",
      "That's the difference between us and the fucking fleas. See, we love big juicy lumbar disc herniations, but they hate hypertension....\" It's hard to think of a lumbar disc herniation as juicy (except literally).",
      "And yet I think I know what they mean. I've often had a juicy bug to track down. Someone who's not a programmer would find it hard to imagine that there could be pleasure in a bug. Surely it's better if everything just works.",
      "In one way, it is. And yet there is undeniably a grim satisfaction in hunting down certain sorts of bugs.Postscript VersionArcFive Questions about Language DesignHow to Become a HackerJapanese Translation"
    ],
    "word_count": 7476,
    "paragraph_count": 154
  },
  "processed_at": "2025-07-26T19:08:57.433239",
  "paragraphs": [
    {
      "original": "May 2001(This article was written as a kind of business plan for a new language. So it is missing (because it takes for granted) the most important feature of a good programming language: very powerful abstractions.)A friend of mine once told an eminent operating systems expert that he wanted to design a really good programming language.",
      "translated": "2001年5月（本文是为一种新语言撰写的商业计划。因此，它缺少了（因为它认为理所当然）一种好的编程语言最重要的特性：非常强大的抽象能力。）我的一位朋友曾告诉一位著名操作系统专家，他想设计一种真正优秀的编程语言。"
    },
    {
      "original": "The expert told him that it would be a waste of time, that programming languages don't become popular or unpopular based on their merits, and so no matter how good his language was, no one would use it.",
      "translated": "专家告诉他，这将是浪费时间，因为编程语言的流行与否并不取决于其优劣，所以无论他的语言多么优秀，也不会有人使用。"
    },
    {
      "original": "At least, that was what had happened to the language he had designed.What does make a language popular? Do popular languages deserve their popularity? Is it worth trying to define a good programming language?",
      "translated": "至少，他设计的语言就是这样。那么，是什么让一种语言流行起来的呢？流行的编程语言是否配得上它们的流行？尝试定义一个好的编程语言是否有意义？"
    },
    {
      "original": "How would you do it?I think the answers to these questions can be found by looking at hackers, and learning what they want. Programming languages are for hackers, and a programming language is good as a programming language (rather than, say, an exercise in denotational semantics or compiler design) if and only if hackers like it.1 The Mechanics of PopularityIt's true, certainly, that most people don't choose programming languages simply based on their merits.",
      "translated": "你怎么做？我认为这些问题的答案可以通过观察黑客并了解他们的需求来找到。编程语言是为黑客设计的，一种编程语言只有在黑客喜欢它时才算是好的编程语言（而不是说，作为指称语义或编译器设计的练习）。受欢迎的机制确实，当然，大多数人选择编程语言时并不是仅仅基于它们的优点。"
    },
    {
      "original": "Most programmers are told what language to use by someone else. And yet I think the effect of such external factors on the popularity of programming languages is not as great as it's sometimes thought to be.",
      "translated": "大多数程序员都是由别人告知使用哪种编程语言的。然而，我认为外部因素对编程语言流行程度的影响并不像人们有时认为的那么大。"
    },
    {
      "original": "I think a bigger problem is that a hacker's idea of a good programming language is not the same as most language designers'.Between the two, the hacker's opinion is the one that matters. Programming languages are not theorems.",
      "translated": "我认为更大的问题是，黑客对好编程语言的看法与大多数语言设计者不同。在这两者之间，黑客的意见才是重要的。编程语言不是定理。"
    },
    {
      "original": "They're tools, designed for people, and they have to be designed to suit human strengths and weaknesses as much as shoes have to be designed for human feet. If a shoe pinches when you put it on, it's a bad shoe, however elegant it may be as a piece of sculpture.It may be that the majority of programmers can't tell a good language from a bad one.",
      "translated": "它们是工具，为人类设计的，必须像鞋子适合人的脚一样，适应人类的优点和缺点。如果穿上鞋子觉得挤脚，那么无论这双鞋作为雕塑作品多么优雅，它都是一双不好的鞋子。可能大多数程序员无法区分一门好的语言和一门不好的语言。"
    },
    {
      "original": "But that's no different with any other tool. It doesn't mean that it's a waste of time to try designing a good language. Expert hackers can tell a good language when they see one, and they'll use it.",
      "translated": "但这与其他任何工具并无二致。这并不意味着尝试设计一种好的语言是浪费时间。专家级黑客一眼就能认出好的语言，并且他们会使用它。"
    },
    {
      "original": "Expert hackers are a tiny minority, admittedly, but that tiny minority write all the good software, and their influence is such that the rest of the programmers will tend to use whatever language they use.",
      "translated": "专家黑客确实只是少数，但正是这个小群体编写了所有的优秀软件，而且他们的影响力如此之大，以至于其他程序员往往会使用他们所使用的编程语言。"
    },
    {
      "original": "Often, indeed, it is not merely influence but command: often the expert hackers are the very people who, as their bosses or faculty advisors, tell the other programmers what language to use.The opinion of expert hackers is not the only force that determines the relative popularity of programming languages — legacy software (Cobol) and hype (Ada, Java) also play a role — but I think it is the most powerful force over the long term.",
      "translated": "通常，这不仅仅是影响力，而是命令：往往是那些资深黑客作为他们的上司或指导教师，告诉其他程序员该使用哪种编程语言。虽然资深黑客的意见并非决定编程语言相对受欢迎程度的唯一力量——遗留软件（如Cobol）和炒作（如Ada、Java）也起作用——但我认为从长远来看，这是最强大的力量。"
    },
    {
      "original": "Given an initial critical mass and enough time, a programming language probably becomes about as popular as it deserves to be. And popularity further separates good languages from bad ones, because feedback from real live users always leads to improvements.",
      "translated": "给定一个初始的临界质量，并经过足够的时间，一种编程语言可能会变得与其应有的受欢迎程度相当。而受欢迎程度进一步将好的语言与不好的语言区分开来，因为来自实际用户的反馈总是会带来改进。"
    },
    {
      "original": "Look at how much any popular language has changed during its life. Perl and Fortran are extreme cases, but even Lisp has changed a lot. Lisp 1.5 didn't have macros, for example; these evolved later, after hackers at MIT had spent a couple years using Lisp to write real programs.",
      "translated": "看看任何一种流行语言在其生命周期中发生了多大的变化。Perl 和 Fortran 是极端的例子，但即便是 Lisp 也变化了很多。例如，Lisp 1.5 没有宏；这些是在 MIT 的黑客们花了几年时间用 Lisp 编写实际程序后逐渐发展起来的。"
    },
    {
      "original": "[1]So whether or not a language has to be good to be popular, I think a language has to be popular to be good. And it has to stay popular to stay good. The state of the art in programming languages doesn't stand still.",
      "translated": "所以，无论一种语言是否必须优秀才能流行，我认为一种语言必须流行才能变得优秀。而且，它必须保持流行才能持续优秀。编程语言的最先进水平是不会停滞不前的。"
    },
    {
      "original": "And yet the Lisps we have today are still pretty much what they had at MIT in the mid-1980s, because that's the last time Lisp had a sufficiently large and demanding user base.Of course, hackers have to know about a language before they can use it.",
      "translated": "然而，我们今天使用的Lisp语言基本上与1980年代中期MIT所使用的版本相差无几，因为那是Lisp最后一次拥有足够庞大且要求苛刻的用户群体。当然，黑客们必须先了解一门语言，才能使用它。"
    },
    {
      "original": "How are they to hear? From other hackers. But there has to be some initial group of hackers using the language for others even to hear about it. I wonder how large this group has to be; how many users make a critical mass?",
      "translated": "他们要如何得知？从其他黑客那里。但是，必须有一批最初使用这种语言的黑客，其他人才能得知。我想知道这个群体需要有多大；多少用户才能形成一个临界量？"
    },
    {
      "original": "Off the top of my head, I'd say twenty. If a language had twenty separate users, meaning twenty users who decided on their own to use it, I'd consider it to be real.Getting there can't be easy. I would not be surprised if it is harder to get from zero to twenty than from twenty to a thousand.",
      "translated": "我随口说说，应该是二十。如果一门语言有二十个独立的使用者，也就是说有二十个人是自己决定使用这门语言的，那我会认为这门语言是真实的。达到这个目标绝非易事。我不会感到惊讶，从零到二十的难度可能比从二十到一千还要大。"
    },
    {
      "original": "The best way to get those initial twenty users is probably to use a trojan horse: to give people an application they want, which happens to be written in the new language.2 External FactorsLet's start by acknowledging one external factor that does affect the popularity of a programming language.",
      "translated": "获得最初那二十个用户的最佳方法可能是使用“特洛伊木马”策略：给他们一个他们想要的应用程序，这个应用程序恰好是用新语言编写的。2 外部因素让我们先承认一个影响编程语言流行度的外部因素。"
    },
    {
      "original": "To become popular, a programming language has to be the scripting language of a popular system. Fortran and Cobol were the scripting languages of early IBM mainframes. C was the scripting language of Unix, and so, later, was Perl.",
      "translated": "要流行起来，一种编程语言必须成为某个流行系统脚本语言。Fortran 和 Cobol 是早期 IBM 主机的脚本语言。C 是 Unix 的脚本语言，后来 Perl 也是如此。"
    },
    {
      "original": "Tcl is the scripting language of Tk. Java and Javascript are intended to be the scripting languages of web browsers.Lisp is not a massively popular language because it is not the scripting language of a massively popular system.",
      "translated": "Tcl 是 Tk 的脚本语言。Java 和 Javascript 被设计为网页浏览器的脚本语言。Lisp 并不是一种非常流行的语言，因为它并不是某个非常流行系统的脚本语言。"
    },
    {
      "original": "What popularity it retains dates back to the 1960s and 1970s, when it was the scripting language of MIT. A lot of the great programmers of the day were associated with MIT at some point. And in the early 1970s, before C, MIT's dialect of Lisp, called MacLisp, was one of the only programming languages a serious hacker would want to use.Today Lisp is the scripting language of two moderately popular systems, Emacs and Autocad, and for that reason I suspect that most of the Lisp programming done today is done in Emacs Lisp or AutoLisp.Programming languages don't exist in isolation.",
      "translated": "它所保留的流行度可以追溯到20世纪60年代和70年代，那时它是麻省理工学院的脚本语言。当时许多杰出的程序员在某个时期与麻省理工学院有关联。而在20世纪70年代早期，在C语言出现之前，麻省理工学院的Lisp方言，即MacLisp，是当时严肃的黑客想要使用的少数几种编程语言之一。如今，Lisp是两个相对流行系统Emacs和AutoCAD的脚本语言，因此我怀疑当今大部分的Lisp编程都是用Emacs Lisp或AutoLisp完成的。编程语言并非孤立存在。"
    },
    {
      "original": "To hack is a transitive verb — hackers are usually hacking something — and in practice languages are judged relative to whatever they're used to hack. So if you want to design a popular language, you either have to supply more than a language, or you have to design your language to replace the scripting language of some existing system.Common Lisp is unpopular partly because it's an orphan.",
      "translated": "黑客是一个及物动词——黑客通常是在破解某样东西——实际上，语言的优劣是相对于它们被用来破解的对象来评判的。所以，如果你想设计一种流行的语言，要么你必须提供比语言本身更多的东西，要么你必须设计你的语言来替代某个现有系统的脚本语言。Common Lisp 不受欢迎部分原因是它是一个孤儿。"
    },
    {
      "original": "It did originally come with a system to hack: the Lisp Machine. But Lisp Machines (along with parallel computers) were steamrollered by the increasing power of general purpose processors in the 1980s.",
      "translated": "它最初确实配备了一个系统来编程：Lisp 机。但 Lisp 机（连同并行计算机）在 20 世纪 80 年代被日益强大的通用处理器所碾压。"
    },
    {
      "original": "Common Lisp might have remained popular if it had been a good scripting language for Unix. It is, alas, an atrociously bad one.One way to describe this situation is to say that a language isn't judged on its own merits.",
      "translated": "如果Common Lisp是一种优秀的Unix脚本语言，它或许还能保持流行。遗憾的是，它在这方面表现得极其糟糕。有一种说法可以描述这种情况：一种语言并不会根据其自身的优点来被评判。"
    },
    {
      "original": "Another view is that a programming language really isn't a programming language unless it's also the scripting language of something. This only seems unfair if it comes as a surprise. I think it's no more unfair than expecting a programming language to have, say, an implementation.",
      "translated": "另一种观点认为，除非某种编程语言同时是某种东西的脚本语言，否则它不能算作真正的编程语言。这看起来不公平，但前提是这种情况让你感到意外。我认为，这并不比期望一种编程语言有其实现来得更不公平。"
    },
    {
      "original": "It's just part of what a programming language is.A programming language does need a good implementation, of course, and this must be free. Companies will pay for software, but individual hackers won't, and it's the hackers you need to attract.A language also needs to have a book about it.",
      "translated": "这仅仅是编程语言的一部分。编程语言当然需要一个良好的实现，而且这个实现必须是免费的。公司会为软件付费，但个人开发者不会，而你需要吸引的正是这些个人开发者。一种语言还需要有一本相关的书籍。"
    },
    {
      "original": "The book should be thin, well-written, and full of good examples. K&R is the ideal here. At the moment I'd almost say that a language has to have a book published by O'Reilly. That's becoming the test of mattering to hackers.There should be online documentation as well.",
      "translated": "这本书应该篇幅简短，文笔优美，并且充满好的例子。在这方面，K&R 是理想的典范。目前我几乎可以说，一种编程语言必须得有 O'Reilly 出版的书。这正逐渐成为对黑客而言重要的测试标准。还应该有在线文档。"
    },
    {
      "original": "In fact, the book can start as online documentation. But I don't think that physical books are outmoded yet. Their format is convenient, and the de facto censorship imposed by publishers is a useful if imperfect filter.",
      "translated": "事实上，这本书可以以在线文档的形式开始。但我认为纸质书还没有过时。它们的格式很方便，而且出版商实际上施加的审查尽管不完美，但仍然是一个有用的过滤器。"
    },
    {
      "original": "Bookstores are one of the most important places for learning about new languages.3 BrevityGiven that you can supply the three things any language needs — a free implementation, a book, and something to hack — how do you make a language that hackers will like?One thing hackers like is brevity.",
      "translated": "书店是了解新语言最重要的场所之一。鉴于你可以提供任何语言所需的三个要素——一个免费的实现、一本书和一个可以编程的对象——你如何创造一种黑客会喜欢的语言呢？黑客喜欢的一点就是简洁。"
    },
    {
      "original": "Hackers are lazy, in the same way that mathematicians and modernist architects are lazy: they hate anything extraneous. It would not be far from the truth to say that a hacker about to write a program decides what language to use, at least subconsciously, based on the total number of characters he'll have to type.",
      "translated": "黑客懒惰的方式和数学家、现代主义建筑师一样：他们讨厌任何多余的东西。说黑客在准备编写程序时，至少是潜意识地，根据他需要输入的总字符数来决定使用哪种语言，这也不会离事实太远。"
    },
    {
      "original": "If this isn't precisely how hackers think, a language designer would do well to act as if it were.It is a mistake to try to baby the user with long-winded expressions that are meant to resemble English.",
      "translated": "即使这并非黑客的真实思维方式，语言设计者也最好将其视为如此。试图用冗长的表达来迎合用户，使之看起来像英语，这其实是一个错误。"
    },
    {
      "original": "Cobol is notorious for this flaw. A hacker would consider being asked to writeadd x to y giving zinstead ofz = x+yas something between an insult to his intelligence and a sin against God.It has sometimes been said that Lisp should use first and rest instead of car and cdr, because it would make programs easier to read.",
      "translated": "Cobol 因这种缺陷而臭名昭著。如果要求黑客用“将 x 加到 y 上，结果给 z”而不是“z = x + y”来编写代码，他们会认为这是对自己智力的侮辱，甚至是亵渎神明。有人有时会说，Lisp 应该使用 first 和 rest 而不是 car 和 cdr，因为这样会使程序更容易阅读。"
    },
    {
      "original": "Maybe for the first couple hours. But a hacker can learn quickly enough that car means the first element of a list and cdr means the rest. Using first and rest means 50% more typing. And they are also different lengths, meaning that the arguments won't line up when they're called, as car and cdr often are, in successive lines.",
      "translated": "可能在最初的几个小时内是这样。但是黑客很快就能学会 car 表示列表的第一个元素，而 cdr 表示其余部分。使用 first 和 rest 会使输入量增加 50%。而且它们的长度不同，这意味着在调用时，如 car 和 cdr 经常在连续的行中使用，参数不会对齐。"
    },
    {
      "original": "I've found that it matters a lot how code lines up on the page. I can barely read Lisp code when it is set in a variable-width font, and friends say this is true for other languages too.Brevity is one place where strongly typed languages lose.",
      "translated": "我发现代码在页面上的排列方式非常重要。当使用可变宽度字体时，我几乎无法阅读Lisp代码，朋友们说这对其他语言也是如此。简洁性是静态类型语言的一个不足之处。"
    },
    {
      "original": "All other things being equal, no one wants to begin a program with a bunch of declarations. Anything that can be implicit, should be.The individual tokens should be short as well. Perl and Common Lisp occupy opposite poles on this question.",
      "translated": "在其他条件相同的情况下，没有人愿意用一堆声明来开始一个程序。任何可以隐式的，都应该隐式处理。各个标记也应该是简短的。Perl 和 Common Lisp 在这个问题上处于完全相反的两个极端。"
    },
    {
      "original": "Perl programs can be almost cryptically dense, while the names of built-in Common Lisp operators are comically long. The designers of Common Lisp probably expected users to have text editors that would type these long names for them.",
      "translated": "Perl 程序几乎可以密不透风到令人费解，而内置的 Common Lisp 操作符的名称则长到滑稽可笑。Common Lisp 的设计者可能预期用户会有能够替他们输入这些长名称的文本编辑器。"
    },
    {
      "original": "But the cost of a long name is not just the cost of typing it. There is also the cost of reading it, and the cost of the space it takes up on your screen.4 HackabilityThere is one thing more important than brevity to a hacker: being able to do what you want.",
      "translated": "但长名字的成本不仅仅是输入它所需的时间。还有阅读它所需的时间，以及它在屏幕上占用的空间。对于黑客来说，有一件事比简洁更重要：能够做自己想做的事情。"
    },
    {
      "original": "In the history of programming languages a surprising amount of effort has gone into preventing programmers from doing things considered to be improper. This is a dangerously presumptuous plan. How can the language designer know what the programmer is going to need to do?",
      "translated": "在编程语言的历史中，人们投入了令人惊讶的努力来阻止程序员做一些被认为是不恰当的事情。这是一个危险的自以为是的计划。语言设计者怎么可能知道程序员将来需要做什么？"
    },
    {
      "original": "I think language designers would do better to consider their target user to be a genius who will need to do things they never anticipated, rather than a bumbler who needs to be protected from himself.",
      "translated": "我认为语言设计者应当将目标用户视为一位天才，他需要完成设计者从未预料到的事情，而不是一个需要被保护以免犯错的笨手笨脚的人。"
    },
    {
      "original": "The bumbler will shoot himself in the foot anyway. You may save him from referring to variables in another package, but you can't save him from writing a badly designed program to solve the wrong problem, and taking forever to do it.Good programmers often want to do dangerous and unsavory things.",
      "translated": "笨手笨脚的人终究会自找麻烦。你可以阻止他引用另一个包中的变量，但无法阻止他设计出糟糕的程序来解决错误的问题，并且花费大量时间。优秀的程序员往往想要做一些危险和不光彩的事情。"
    },
    {
      "original": "By unsavory I mean things that go behind whatever semantic facade the language is trying to present: getting hold of the internal representation of some high-level abstraction, for example. Hackers like to hack, and hacking means getting inside things and second guessing the original designer.Let yourself be second guessed.",
      "translated": "所谓的不端行为，是指那些绕过语言试图呈现的任何语义表象的行为：例如，获取某些高级抽象的内部表示。黑客喜欢破解，而破解意味着深入内部并预测原始设计者的意图。让自己被预测。"
    },
    {
      "original": "When you make any tool, people use it in ways you didn't intend, and this is especially true of a highly articulated tool like a programming language. Many a hacker will want to tweak your semantic model in a way that you never imagined.",
      "translated": "当你制作任何工具时，人们会以你未曾预料的方式使用它，这一点对于像编程语言这样高度精细的工具尤为明显。许多程序员会希望以你从未设想的方式调整你的语义模型。"
    },
    {
      "original": "I say, let them; give the programmer access to as much internal stuff as you can without endangering runtime systems like the garbage collector.In Common Lisp I have often wanted to iterate through the fields of a struct — to comb out references to a deleted object, for example, or find fields that are uninitialized.",
      "translated": "我说，就让他们这样做吧；在不危及垃圾收集器等运行时系统的情况下，尽可能多地让程序员访问内部内容。在 Common Lisp 中，我经常希望遍历结构体的各个字段——例如，梳理出对已删除对象的引用，或者查找未初始化的字段。"
    },
    {
      "original": "I know the structs are just vectors underneath. And yet I can't write a general purpose function that I can call on any struct. I can only access the fields by name, because that's what a struct is supposed to mean.A hacker may only want to subvert the intended model of things once or twice in a big program.",
      "translated": "我知道这些结构体本质上就是向量。然而，我不能编写一个可以应用于任何结构体的通用函数。我只能通过字段名来访问它们，因为这就是结构体的本意。黑客可能在一个大型程序中只希望破坏预定的模型一两次。"
    },
    {
      "original": "But what a difference it makes to be able to. And it may be more than a question of just solving a problem. There is a kind of pleasure here too. Hackers share the surgeon's secret pleasure in poking about in gross innards, the teenager's secret pleasure in popping zits.",
      "translated": "但能够做到这一点有多么大的不同。这不仅仅是一个解决问题的问题。这里还有一种乐趣。黑客们分享着外科医生在探索复杂内脏时那种隐秘的快感，以及青少年挤痘痘时的那种隐秘的愉悦。"
    },
    {
      "original": "[2] For boys, at least, certain kinds of horrors are fascinating. Maxim magazine publishes an annual volume of photographs, containing a mix of pin-ups and grisly accidents. They know their audience.Historically, Lisp has been good at letting hackers have their way.",
      "translated": "[2] 对于男孩来说，至少某些类型的恐怖是吸引人的。《Maxim》杂志每年都会出版一本照片集，其中包含美女写真和可怕的事故照片。他们了解自己的读者。历史上，Lisp 语言一直擅长让黑客随心所欲。"
    },
    {
      "original": "The political correctness of Common Lisp is an aberration. Early Lisps let you get your hands on everything. A good deal of that spirit is, fortunately, preserved in macros. What a wonderful thing, to be able to make arbitrary transformations on the source code.Classic macros are a real hacker's tool — simple, powerful, and dangerous.",
      "translated": "Common Lisp 的政治正确性是一种异常。早期的 Lisp 让你可以接触到一切。幸运的是，这种精神在宏中得到了很大程度的保留。能够对源代码进行任意转换，真是太美妙了。经典的宏是一种真正的黑客工具——简单、强大且危险。"
    },
    {
      "original": "It's so easy to understand what they do: you call a function on the macro's arguments, and whatever it returns gets inserted in place of the macro call. Hygienic macros embody the opposite principle.",
      "translated": "理解它们的功能是如此简单：你对宏的参数调用一个函数，函数返回的内容将被插入到宏调用的位置。而卫生宏则体现了相反的原则。"
    },
    {
      "original": "They try to protect you from understanding what they're doing. I have never heard hygienic macros explained in one sentence. And they are a classic example of the dangers of deciding what programmers are allowed to want.",
      "translated": "他们试图阻止你理解他们在做什么。我从未听说过能在一句话中解释清楚卫生宏。而它们是决定程序员被允许需求的经典危险示例。"
    },
    {
      "original": "Hygienic macros are intended to protect me from variable capture, among other things, but variable capture is exactly what I want in some macros.A really good language should be both clean and dirty: cleanly designed, with a small core of well understood and highly orthogonal operators, but dirty in the sense that it lets hackers have their way with it.",
      "translated": "卫生宏旨在保护我免受变量捕获等问题的影响，但有时我恰恰需要在某些宏中实现变量捕获。一种真正优秀的语言应当既干净又灵活：设计上简洁明了，拥有一套小巧且高度正交的核心操作符，同时又足够灵活，允许黑客随心所欲地使用它。"
    },
    {
      "original": "C is like this. So were the early Lisps. A real hacker's language will always have a slightly raffish character.A good programming language should have features that make the kind of people who use the phrase \"software engineering\" shake their heads disapprovingly.",
      "translated": "C 就是这样的。早期的 Lisp 也是如此。真正的黑客语言总是带有一点粗犷的特质。一个好的编程语言应该具有一些让那些使用“软件工程”这一说法的人摇头不赞同的功能。"
    },
    {
      "original": "At the other end of the continuum are languages like Ada and Pascal, models of propriety that are good for teaching and not much else.5 Throwaway ProgramsTo be attractive to hackers, a language must be good for writing the kinds of programs they want to write.",
      "translated": "在另一端则是像Ada和Pascal这样的语言，它们是规范的典范，适合教学，但除此之外用处不大。一次性程序要吸引黑客，一种语言必须适合编写他们想要编写的程序类型。"
    },
    {
      "original": "And that means, perhaps surprisingly, that it has to be good for writing throwaway programs.A throwaway program is a program you write quickly for some limited task: a program to automate some system administration task, or generate test data for a simulation, or convert data from one format to another.",
      "translated": "这意味着，也许令人惊讶的是，它必须适合编写一次性程序。一次性程序是指你为了某个有限的任务而快速编写的一个程序：例如用于自动化某些系统管理任务、生成模拟的测试数据或转换数据格式的程序。"
    },
    {
      "original": "The surprising thing about throwaway programs is that, like the \"temporary\" buildings built at so many American universities during World War II, they often don't get thrown away. Many evolve into real programs, with real features and real users.I have a hunch that the best big programs begin life this way, rather than being designed big from the start, like the Hoover Dam.",
      "translated": "令人惊讶的是，一次性程序就像第二次世界大战期间美国许多大学建造的“临时”建筑一样，往往不会被废弃。许多程序发展成为具有真实功能和真实用户的真实程序。我有一种预感，最好的大型程序都是以这种方式开始生命的，而不是像胡佛水坝那样从一开始就设计成大型项目。"
    },
    {
      "original": "It's terrifying to build something big from scratch. When people take on a project that's too big, they become overwhelmed. The project either gets bogged down, or the result is sterile and wooden: a shopping mall rather than a real downtown, Brasilia rather than Rome, Ada rather than C.Another way to get a big program is to start with a throwaway program and keep improving it.",
      "translated": "从零开始构建大型项目令人感到恐惧。当人们承担了一个过于庞大的项目时，他们往往会感到压力山大。项目要么停滞不前，要么其结果显得死气沉沉、缺乏生气：一个购物中心而不是真正的市中心，巴西利亚而不是罗马，Ada 而不是 C。另一种实现大型项目的方法是，从一个临时程序开始，然后不断改进它。"
    },
    {
      "original": "This approach is less daunting, and the design of the program benefits from evolution. I think, if one looked, that this would turn out to be the way most big programs were developed. And those that did evolve this way are probably still written in whatever language they were first written in, because it's rare for a program to be ported, except for political reasons.",
      "translated": "这种方法不那么令人生畏，程序的设计也得益于进化。我认为，如果仔细观察，会发现大多数大型程序都是这样开发的。而那些确实这样进化的程序，可能仍然用它们最初所用的语言编写，因为程序很少会被移植，除非出于政治原因。"
    },
    {
      "original": "And so, paradoxically, if you want to make a language that is used for big systems, you have to make it good for writing throwaway programs, because that's where big systems come from.Perl is a striking example of this idea.",
      "translated": "因此，矛盾的是，如果你想创造一种用于大型系统的语言，你必须使其适合编写临时程序，因为大型系统正是从这些临时程序发展而来的。Perl 就是这一理念的一个显著例子。"
    },
    {
      "original": "It was not only designed for writing throwaway programs, but was pretty much a throwaway program itself. Perl began life as a collection of utilities for generating reports, and only evolved into a programming language as the throwaway programs people wrote in it grew larger.",
      "translated": "它不仅被设计用于编写一次性程序，本身就是个几乎可以被随意丢弃的程序。Perl 最初是一组用于生成报告的实用工具，只是随着人们用它编写的一次性程序不断变大，才逐渐演变成了一种编程语言。"
    },
    {
      "original": "It was not until Perl 5 (if then) that the language was suitable for writing serious programs, and yet it was already massively popular.What makes a language good for throwaway programs? To start with, it must be readily available.",
      "translated": "直到Perl 5（如果那时算的话），这门语言才适合编写严肃的程序，然而它已经非常流行。那么，什么使一门语言适合编写临时程序呢？首先，它必须易于获取。"
    },
    {
      "original": "A throwaway program is something that you expect to write in an hour. So the language probably must already be installed on the computer you're using. It can't be something you have to install before you use it.",
      "translated": "一个一次性程序是指你预期在一个小时内就能写完的程序。因此，你使用的计算机上可能已经安装了所需的编程语言。它不能是需要先安装才能使用的那种。"
    },
    {
      "original": "It has to be there. C was there because it came with the operating system. Perl was there because it was originally a tool for system administrators, and yours had already installed it.Being available means more than being installed, though.",
      "translated": "它必须存在。C 语言存在是因为它随操作系统一起提供。Perl 存在是因为它最初是为系统管理员设计的工具，而你的系统管理员已经安装了它。然而，可用不仅仅意味着已安装。"
    },
    {
      "original": "An interactive language, with a command-line interface, is more available than one that you have to compile and run separately. A popular programming language should be interactive, and start up fast.Another thing you want in a throwaway program is brevity.",
      "translated": "一种具有命令行界面的交互式语言比需要单独编译和运行的语言更方便。一种流行的编程语言应该是交互式的，并且启动速度快。在一次性程序中，你还需要简洁性。"
    },
    {
      "original": "Brevity is always attractive to hackers, and never more so than in a program they expect to turn out in an hour.6 LibrariesOf course the ultimate in brevity is to have the program already written for you, and merely to call it.",
      "translated": "简洁总是对黑客有吸引力，尤其是在他们预计一个程序能在一小时内完成的时候。当然，最简洁的方式是程序已经有人写好了，你只需要调用它。"
    },
    {
      "original": "And this brings us to what I think will be an increasingly important feature of programming languages: library functions. Perl wins because it has large libraries for manipulating strings. This class of library functions are especially important for throwaway programs, which are often originally written for converting or extracting data.",
      "translated": "这让我们谈到了我认为将变得越来越重要的编程语言特性：库函数。Perl之所以胜出，是因为它拥有大量用于操作字符串的库。这类库函数对于一次性程序尤为重要，这些程序通常最初是为了转换或提取数据而编写的。"
    },
    {
      "original": "Many Perl programs probably begin as just a couple library calls stuck together.I think a lot of the advances that happen in programming languages in the next fifty years will have to do with library functions.",
      "translated": "许多Perl程序可能最初只是几个库调用的组合。我认为，在未来五十年中，编程语言的许多进步都将与库函数有关。"
    },
    {
      "original": "I think future programming languages will have libraries that are as carefully designed as the core language. Programming language design will not be about whether to make your language strongly or weakly typed, or object oriented, or functional, or whatever, but about how to design great libraries.",
      "translated": "我认为未来的编程语言将拥有与核心语言一样精心设计的库。编程语言的设计将不再局限于是否使语言成为强类型或弱类型，面向对象或函数式，而是关于如何设计优秀的库。"
    },
    {
      "original": "The kind of language designers who like to think about how to design type systems may shudder at this. It's almost like writing applications! Too bad. Languages are for programmers, and libraries are what programmers need.It's hard to design good libraries.",
      "translated": "喜欢思考如何设计类型系统的语言设计者可能会对此感到不寒而栗。这几乎就像是在编写应用程序！可惜的是，语言是为程序员设计的，而库是程序员所需要的。设计一个好的库是很困难的。"
    },
    {
      "original": "It's not simply a matter of writing a lot of code. Once the libraries get too big, it can sometimes take longer to find the function you need than to write the code yourself. Libraries need to be designed using a small set of orthogonal operators, just like the core language.",
      "translated": "这不仅仅是编写大量代码的问题。一旦库变得太大，有时候找到你需要的函数所花费的时间可能比自己编写代码还要长。库的设计需要使用一套精简的正交操作符，就像核心语言一样。"
    },
    {
      "original": "It ought to be possible for the programmer to guess what library call will do what he needs.Libraries are one place Common Lisp falls short. There are only rudimentary libraries for manipulating strings, and almost none for talking to the operating system.",
      "translated": "程序员应该能够猜测出哪个库调用能满足他的需求。库是Common Lisp的一个短板。对于字符串操作，只有基础的库，而几乎没有任何与操作系统交互的库。"
    },
    {
      "original": "For historical reasons, Common Lisp tries to pretend that the OS doesn't exist. And because you can't talk to the OS, you're unlikely to be able to write a serious program using only the built-in operators in Common Lisp.",
      "translated": "由于历史原因，Common Lisp 试图假装操作系统不存在。而因为你无法与操作系统通信，所以你不太可能仅使用 Common Lisp 的内置操作符编写出一个严肃的程序。"
    },
    {
      "original": "You have to use some implementation-specific hacks as well, and in practice these tend not to give you everything you want. Hackers would think a lot more highly of Lisp if Common Lisp had powerful string libraries and good OS support.7 SyntaxCould a language with Lisp's syntax, or more precisely, lack of syntax, ever become popular?",
      "translated": "你还需要使用一些特定实现的技巧，而在实践中，这些技巧往往不能给你你想要的一切。如果 Common Lisp 拥有强大的字符串库和良好的操作系统支持，黑客们会对 Lisp 评价更高。语法：一种具有 Lisp 语法，或者说更准确地讲，缺乏语法的语言，有可能变得流行吗？"
    },
    {
      "original": "I don't know the answer to this question. I do think that syntax is not the main reason Lisp isn't currently popular. Common Lisp has worse problems than unfamiliar syntax. I know several programmers who are comfortable with prefix syntax and yet use Perl by default, because it has powerful string libraries and can talk to the os.There are two possible problems with prefix notation: that it is unfamiliar to programmers, and that it is not dense enough.",
      "translated": "我不知道这个问题的答案。我认为语法并不是Lisp目前不流行的主要原因。Common Lisp的问题比不熟悉的语法还要严重。我认识几位程序员，他们对前缀语法很熟悉，但仍然默认使用Perl，因为Perl拥有强大的字符串库并且可以与操作系统进行交互。前缀表示法可能存在的两个问题是：对程序员来说不够熟悉，以及不够紧凑。"
    },
    {
      "original": "The conventional wisdom in the Lisp world is that the first problem is the real one. I'm not so sure. Yes, prefix notation makes ordinary programmers panic. But I don't think ordinary programmers' opinions matter.",
      "translated": "在Lisp世界中，普遍的看法是第一个问题才是真正的问题。我不太确定这一点。诚然，前缀表示法会让普通程序员感到恐慌。但我不认为普通程序员的意见很重要。"
    },
    {
      "original": "Languages become popular or unpopular based on what expert hackers think of them, and I think expert hackers might be able to deal with prefix notation. Perl syntax can be pretty incomprehensible, but that has not stood in the way of Perl's popularity.",
      "translated": "语言的受欢迎程度取决于专家黑客对它们的看法，我认为专家黑客可能能够应对前缀表示法。Perl 的语法可能非常难以理解，但这并没有阻碍 Perl 的流行。"
    },
    {
      "original": "If anything it may have helped foster a Perl cult.A more serious problem is the diffuseness of prefix notation. For expert hackers, that really is a problem. No one wants to write (aref a x y) when they could write a[x,y].In this particular case there is a way to finesse our way out of the problem.",
      "translated": "如果有什么影响的话，可能就是助长了Perl的崇拜。一个更严重的问题是前缀表示法的散漫性。对于专家黑客来说，这确实是一个问题。没有人愿意写 (aref a x y)，而他们可以写 a[x,y]。在这种特定情况下，我们有一个办法可以巧妙地解决这个问题。"
    },
    {
      "original": "If we treat data structures as if they were functions on indexes, we could write (a x y) instead, which is even shorter than the Perl form. Similar tricks may shorten other types of expressions.We can get rid of (or make optional) a lot of parentheses by making indentation significant.",
      "translated": "如果我们把数据结构当作是对索引的函数来处理，我们可以写成 (a x y)，这比 Perl 的形式还要简洁。类似的技巧可以缩短其他类型的表达式。通过使缩进变得重要，我们可以去掉（或使之成为可选的）很多括号。"
    },
    {
      "original": "That's how programmers read code anyway: when indentation says one thing and delimiters say another, we go by the indentation. Treating indentation as significant would eliminate this common source of bugs as well as making programs shorter.Sometimes infix syntax is easier to read.",
      "translated": "这就是程序员阅读代码的方式：当缩进表示一种意思而分隔符表示另一种意思时，我们依据缩进。将缩进视为重要部分可以消除这种常见的错误来源，同时使程序更简洁。有时中缀语法更容易阅读。"
    },
    {
      "original": "This is especially true for math expressions. I've used Lisp my whole programming life and I still don't find prefix math expressions natural. And yet it is convenient, especially when you're generating code, to have operators that take any number of arguments.",
      "translated": "这尤其适用于数学表达式。我整个编程生涯都在使用Lisp，但至今仍觉得前缀数学表达式不够自然。然而，当生成代码时，能够接受任意数量参数的运算符确实非常方便。"
    },
    {
      "original": "So if we do have infix syntax, it should probably be implemented as some kind of read-macro.I don't think we should be religiously opposed to introducing syntax into Lisp, as long as it translates in a well-understood way into underlying s-expressions.",
      "translated": "所以，如果我们确实需要中缀语法，它应该被实现为某种读取宏。我认为我们不应该对在Lisp中引入语法过于排斥，只要它能够以一种大家熟知的方式转换为底层的s-表达式。"
    },
    {
      "original": "There is already a good deal of syntax in Lisp. It's not necessarily bad to introduce more, as long as no one is forced to use it. In Common Lisp, some delimiters are reserved for the language, suggesting that at least some of the designers intended to have more syntax in the future.One of the most egregiously unlispy pieces of syntax in Common Lisp occurs in format strings; format is a language in its own right, and that language is not Lisp.",
      "translated": "Lisp 已经拥有了相当丰富的语法。只要不强制任何人使用，引入更多的语法并不一定是坏事。在 Common Lisp 中，一些分隔符被预留给了语言本身，这表明至少部分设计者有意在未来增加更多语法。Common Lisp 中最不符合 Lisp 风格的语法之一出现在格式字符串中；格式化实际上是一种独立的语言，而这种语言并不是 Lisp。"
    },
    {
      "original": "If there were a plan for introducing more syntax into Lisp, format specifiers might be able to be included in it. It would be a good thing if macros could generate format specifiers the way they generate any other kind of code.An eminent Lisp hacker told me that his copy of CLTL falls open to the section format.",
      "translated": "如果有一个计划是向Lisp引入更多的语法，那么格式说明符可能会被包含在这个计划中。如果宏能够像生成其他任何类型的代码那样生成格式说明符，那将是一件好事。一位著名的Lisp高手告诉我，他的CLTL副本总是自动翻到格式说明符那一节。"
    },
    {
      "original": "Mine too. This probably indicates room for improvement. It may also mean that programs do a lot of I/O.8 EfficiencyA good language, as everyone knows, should generate fast code. But in practice I don't think fast code comes primarily from things you do in the design of the language.",
      "translated": "我也是。这可能表明有改进的空间。这也可能意味着程序做了大量的输入/输出。效率众所周知，一个好的语言应该生成快速的代码。但实际操作中，我认为快速的代码主要不是来自你在语言设计中所做的事情。"
    },
    {
      "original": "As Knuth pointed out long ago, speed only matters in certain critical bottlenecks. And as many programmers have observed since, one is very often mistaken about where these bottlenecks are.So, in practice, the way to get fast code is to have a very good profiler, rather than by, say, making the language strongly typed.",
      "translated": "正如高德纳很久以前指出的，速度只在某些关键瓶颈处才重要。而正如许多程序员自那以后所观察到的，人们常常误判这些瓶颈所在。因此，实际上，要获得快速的代码，拥有一个非常好的性能分析器才是关键，而不是通过，比如说，使语言具有强类型。"
    },
    {
      "original": "You don't need to know the type of every argument in every call in the program. You do need to be able to declare the types of arguments in the bottlenecks. And even more, you need to be able to find out where the bottlenecks are.One complaint people have had with Lisp is that it's hard to tell what's expensive.",
      "translated": "你不需要知道程序中每次调用的所有参数的类型。你需要能够声明瓶颈处的参数类型。更重要的是，你需要能够找出这些瓶颈在哪里。人们对Lisp的一个抱怨是，很难判断哪些操作是昂贵的。"
    },
    {
      "original": "This might be true. It might also be inevitable, if you want to have a very abstract language. And in any case I think good profiling would go a long way toward fixing the problem: you'd soon learn what was expensive.Part of the problem here is social.",
      "translated": "这可能是真的。如果你想要一种非常抽象的语言，这也可能是不可避免的。无论如何，我认为良好的性能分析将大大有助于解决这个问题：你很快就会知道哪些地方开销大。这里的问题部分是社会性的。"
    },
    {
      "original": "Language designers like to write fast compilers. That's how they measure their skill. They think of the profiler as an add-on, at best. But in practice a good profiler may do more to improve the speed of actual programs written in the language than a compiler that generates fast code.",
      "translated": "语言设计者喜欢编写快速的编译器。这是他们衡量自己技能的方式。他们最多把剖析器（性能分析器）视为一个附加组件。但在实际中，一个好的剖析器可能比生成快速代码的编译器更能提高用该语言编写的实际程序的速度。"
    },
    {
      "original": "Here, again, language designers are somewhat out of touch with their users. They do a really good job of solving slightly the wrong problem.It might be a good idea to have an active profiler — to push performance data to the programmer instead of waiting for him to come asking for it.",
      "translated": "在这里，语言设计者再次与用户脱节。他们确实很好地解决了一个略微偏离的问题。或许应该有一个活跃的性能分析器——将性能数据推送给程序员，而不是等着他们来询问。"
    },
    {
      "original": "For example, the editor could display bottlenecks in red when the programmer edits the source code. Another approach would be to somehow represent what's happening in running programs. This would be an especially big win in server-based applications, where you have lots of running programs to look at.",
      "translated": "例如，编辑器可以在程序员编辑源代码时用红色显示瓶颈。另一种方法是某种方式表示正在运行的程序中发生的情况。这在基于服务器的应用程序中尤其有用，因为你需要查看大量正在运行的程序。"
    },
    {
      "original": "An active profiler could show graphically what's happening in memory as a program's running, or even make sounds that tell what's happening.Sound is a good cue to problems. In one place I worked, we had a big board of dials showing what was happening to our web servers.",
      "translated": "一个活跃的性能分析器可以图形化地显示程序运行时内存中发生的情况，甚至可以通过声音来传达正在发生的事情。声音是发现问题的良好线索。在我曾经工作过的一个地方，我们有一个大面板，上面装有仪表，显示我们的网络服务器的运行状况。"
    },
    {
      "original": "The hands were moved by little servomotors that made a slight noise when they turned. I couldn't see the board from my desk, but I found that I could tell immediately, by the sound, when there was a problem with a server.It might even be possible to write a profiler that would automatically detect inefficient algorithms.",
      "translated": "手是由小型伺服电机驱动的，转动时会发出轻微的噪音。从我的桌子上看不见控制板，但我发现可以通过声音立刻判断出服务器是否有问题。甚至可能编写一个分析器，自动检测出低效的算法。"
    },
    {
      "original": "I would not be surprised if certain patterns of memory access turned out to be sure signs of bad algorithms. If there were a little guy running around inside the computer executing our programs, he would probably have as long and plaintive a tale to tell about his job as a federal government employee.",
      "translated": "我不会对某些内存访问模式成为糟糕算法的明确标志感到惊讶。如果在计算机内部有一个小人在执行我们的程序，他大概也会像联邦政府雇员那样，对他的工作有一段漫长而哀怨的叙述。"
    },
    {
      "original": "I often have a feeling that I'm sending the processor on a lot of wild goose chases, but I've never had a good way to look at what it's doing.A number of Lisps now compile into byte code, which is then executed by an interpreter.",
      "translated": "我常常有种感觉，好像我在让处理器做许多徒劳无功的工作，但我一直找不到一个好的方法来看它到底在做什么。现在，许多Lisp方言可以编译成字节码，然后由解释器执行。"
    },
    {
      "original": "This is usually done to make the implementation easier to port, but it could be a useful language feature. It might be a good idea to make the byte code an official part of the language, and to allow programmers to use inline byte code in bottlenecks.",
      "translated": "这通常是为了使实现更容易移植，但这也可能是一个有用的语言特性。将字节码作为语言的官方部分，并允许程序员在瓶颈处使用内联字节码，可能是一个好主意。"
    },
    {
      "original": "Then such optimizations would be portable too.The nature of speed, as perceived by the end-user, may be changing. With the rise of server-based applications, more and more programs may turn out to be i/o-bound.",
      "translated": "那么，这样的优化也将是可移植的。终端用户所感知的速度特性可能会发生变化。随着基于服务器的应用程序的兴起，越来越多的程序可能会变成I/O受限。"
    },
    {
      "original": "It will be worth making i/o fast. The language can help with straightforward measures like simple, fast, formatted output functions, and also with deep structural changes like caching and persistent objects.Users are interested in response time.",
      "translated": "提高输入输出的速度是值得的。语言可以通过一些直接的措施来帮助实现，比如简单的、快速的格式化输出函数，也可以通过深层次的结构变化来实现，比如缓存和持久化对象。用户关心的是响应时间。"
    },
    {
      "original": "But another kind of efficiency will be increasingly important: the number of simultaneous users you can support per processor. Many of the interesting applications written in the near future will be server-based, and the number of users per server is the critical question for anyone hosting such applications.",
      "translated": "但另一种效率将变得越来越重要：每个处理器可以支持的并发用户数。未来不久编写的一些有趣的应用程序将是基于服务器的，对于托管此类应用程序的任何人来说，每台服务器支持的用户数是关键问题。"
    },
    {
      "original": "In the capital cost of a business offering a server-based application, this is the divisor.For years, efficiency hasn't mattered much in most end-user applications. Developers have been able to assume that each user would have an increasingly powerful processor sitting on their desk.",
      "translated": "在提供基于服务器的应用程序的企业资本成本中，这是除数。多年来，效率在大多数最终用户应用程序中并没有太大的影响。开发人员可以假设每个用户桌面上都会有一台性能越来越强大的处理器。"
    },
    {
      "original": "And by Parkinson's Law, software has expanded to use the resources available. That will change with server-based applications. In that world, the hardware and software will be supplied together. For companies that offer server-based applications, it will make a very big difference to the bottom line how many users they can support per server.In some applications, the processor will be the limiting factor, and execution speed will be the most important thing to optimize.",
      "translated": "根据帕金森定律，软件已经扩展到了可用资源的极限。这种情况将会随着基于服务器的应用程序的出现而改变。在那个世界里，硬件和软件将一起提供。对于提供基于服务器应用程序的公司而言，每个服务器能支持的用户数量将对利润产生巨大影响。在某些应用程序中，处理器将成为限制因素，而执行速度将是最重要的优化目标。"
    },
    {
      "original": "But often memory will be the limit; the number of simultaneous users will be determined by the amount of memory you need for each user's data. The language can help here too. Good support for threads will enable all the users to share a single heap.",
      "translated": "但往往内存会成为限制因素；同时在线用户的数量将由每个用户数据所需的内存量决定。语言在这里也能提供帮助。良好的线程支持将使所有用户能够共享单一的堆内存。"
    },
    {
      "original": "It may also help to have persistent objects and/or language level support for lazy loading.9 TimeThe last ingredient a popular language needs is time. No one wants to write programs in a language that might go away, as so many programming languages do.",
      "translated": "拥有持久化对象和/或语言级别的懒加载支持也会有所帮助。时间最后一项重要的元素是时间。没有人愿意用一种可能会消失的编程语言来编写程序，而这种情况在许多编程语言中确实会发生。"
    },
    {
      "original": "So most hackers will tend to wait until a language has been around for a couple years before even considering using it.Inventors of wonderful new things are often surprised to discover this, but you need time to get any message through to people.",
      "translated": "所以，大多数黑客会倾向于等待一种语言问世几年后才会考虑使用它。新事物的发明者们常常会惊讶地发现这一点，但实际上，你需要时间才能让任何信息被人们接受。"
    },
    {
      "original": "A friend of mine rarely does anything the first time someone asks him. He knows that people sometimes ask for things that they turn out not to want. To avoid wasting his time, he waits till the third or fourth time he's asked to do something; by then, whoever's asking him may be fairly annoyed, but at least they probably really do want whatever they're asking for.Most people have learned to do a similar sort of filtering on new things they hear about.",
      "translated": "我的一个朋友很少在别人第一次请求时就去做某事。他知道人们有时候会要求一些他们最终并不需要的东西。为了避免浪费时间，他会等到第三次或第四次被要求时才去做；到那时，请求他的人可能会相当恼火，但至少他们很可能确实需要他们所要求的东西。大多数人都学会了对听到的新事物进行类似的过滤。"
    },
    {
      "original": "They don't even start paying attention until they've heard about something ten times. They're perfectly justified: the majority of hot new whatevers do turn out to be a waste of time, and eventually go away.",
      "translated": "他们甚至要听到十次才会开始关注。他们这样做完全是有道理的：大多数所谓的新鲜事物最终都会证明是浪费时间，然后逐渐消失。"
    },
    {
      "original": "By delaying learning VRML, I avoided having to learn it at all.So anyone who invents something new has to expect to keep repeating their message for years before people will start to get it. We wrote what was, as far as I know, the first web-server based application, and it took us years to get it through to people that it didn't have to be downloaded.",
      "translated": "通过推迟学习VRML，我避免了完全去学习它。因此，任何发明新事物的人都必须预料到，他们需要花费数年时间不断重复自己的信息，人们才会开始理解。据我所知，我们编写了第一个基于网络服务器的应用程序，而让我们花费了多年时间才让人们明白，这个程序不需要下载。"
    },
    {
      "original": "It wasn't that they were stupid. They just had us tuned out.The good news is, simple repetition solves the problem. All you have to do is keep telling your story, and eventually people will start to hear.",
      "translated": "这并不是因为他们愚蠢。他们只是对我们置若罔闻。好消息是，简单的重复就能解决问题。你只需要不断讲述你的故事，最终人们会开始倾听。"
    },
    {
      "original": "It's not when people notice you're there that they pay attention; it's when they notice you're still there.It's just as well that it usually takes a while to gain momentum. Most technologies evolve a good deal even after they're first launched — programming languages especially.",
      "translated": "人们注意到你的存在时并不会给予关注；当他们意识到你一直都在时，才会真正关注。好在通常需要一段时间才能积聚势头。大多数技术即使在首次推出后也会有很大的发展——编程语言尤其如此。"
    },
    {
      "original": "Nothing could be better, for a new techology, than a few years of being used only by a small number of early adopters. Early adopters are sophisticated and demanding, and quickly flush out whatever flaws remain in your technology.",
      "translated": "对于一项新技术而言，没有什么比在最初几年只被一小部分早期采用者使用更好的了。早期采用者既 sophisticated 又 demanding，能够迅速发现你技术中仍存在的任何缺陷。"
    },
    {
      "original": "When you only have a few users you can be in close contact with all of them. And early adopters are forgiving when you improve your system, even if this causes some breakage.There are two ways new technology gets introduced: the organic growth method, and the big bang method.",
      "translated": "当你只有少数用户时，你可以与他们保持密切联系。早期采用者会在你改进系统时给予宽容，即使这会导致一些问题。新技术的引入有两种方式：有机增长法和大爆炸法。"
    },
    {
      "original": "The organic growth method is exemplified by the classic seat-of-the-pants underfunded garage startup. A couple guys, working in obscurity, develop some new technology. They launch it with no marketing and initially have only a few (fanatically devoted) users.",
      "translated": "有机增长方法的典型例子是经典的依靠直觉、资金不足的车库创业。几个人在默默无闻中工作，开发出某种新技术。他们没有任何营销就推出了这项技术，最初只有少数（狂热忠诚的）用户。"
    },
    {
      "original": "They continue to improve the technology, and meanwhile their user base grows by word of mouth. Before they know it, they're big.The other approach, the big bang method, is exemplified by the VC-backed, heavily marketed startup.",
      "translated": "他们不断改进技术，同时用户群通过口口相传来增长。不知不觉中，他们就变得很大了。另一种方法，即大爆炸式的方法，是由风险投资支持、大肆宣传的初创公司所体现的。"
    },
    {
      "original": "They rush to develop a product, launch it with great publicity, and immediately (they hope) have a large user base.Generally, the garage guys envy the big bang guys. The big bang guys are smooth and confident and respected by the VCs.",
      "translated": "他们急于开发产品，大张旗鼓地推出，希望立刻就能拥有大量的用户群。通常，车库派羡慕大爆炸派。大爆炸派表现得从容自信，受到风险投资家的尊敬。"
    },
    {
      "original": "They can afford the best of everything, and the PR campaign surrounding the launch has the side effect of making them celebrities. The organic growth guys, sitting in their garage, feel poor and unloved.",
      "translated": "他们可以享受最好的一切，而围绕产品上市的公关活动也让他们成为了名人。那些在车库中努力实现有机增长的团队则感到贫穷且不被重视。"
    },
    {
      "original": "And yet I think they are often mistaken to feel sorry for themselves. Organic growth seems to yield better technology and richer founders than the big bang method. If you look at the dominant technologies today, you'll find that most of them grew organically.This pattern doesn't only apply to companies.",
      "translated": "然而，我认为他们常常为自己感到遗憾是错误的。有机增长似乎比“大爆炸”式方法产生更好的技术和更富有的创始人。如果你看看当今主导的技术，你会发现大多数都是有机增长起来的。这种模式不仅适用于公司。"
    },
    {
      "original": "You see it in sponsored research too. Multics and Common Lisp were big-bang projects, and Unix and MacLisp were organic growth projects.10 Redesign\"The best writing is rewriting,\" wrote E. B. White. Every good writer knows this, and it's true for software too.",
      "translated": "你也可以在资助的研究中看到这一点。Multics 和 Common Lisp 是大爆炸式的项目，而 Unix 和 MacLisp 则是有机增长的项目。10 重新设计“最好的写作是重写，”E. B. White 写道。每个优秀的作家都知道这一点，对于软件也是如此。"
    },
    {
      "original": "The most important part of design is redesign. Programming languages, especially, don't get redesigned enough.To write good software you must simultaneously keep two opposing ideas in your head. You need the young hacker's naive faith in his abilities, and at the same time the veteran's skepticism.",
      "translated": "设计中最重要的部分是重新设计。特别是编程语言，往往缺乏足够的重新设计。要编写好的软件，你必须同时在脑海中保持两种对立的想法。你需要年轻黑客对自己能力的天真信任，同时也要有老手的怀疑态度。"
    },
    {
      "original": "You have to be able to think how hard can it be? with one half of your brain while thinking it will never work with the other.The trick is to realize that there's no real contradiction here. You want to be optimistic and skeptical about two different things.",
      "translated": "你必须能够用一半的大脑思考“这有多难？”同时用另一半的大脑思考“这永远行不通”。关键是要意识到这里其实没有真正的矛盾。你对两件不同的事情要保持乐观和怀疑。"
    },
    {
      "original": "You have to be optimistic about the possibility of solving the problem, but skeptical about the value of whatever solution you've got so far.People who do good work often think that whatever they're working on is no good.",
      "translated": "你必须对解决问题的可能性保持乐观，但对迄今为止所得到的任何解决方案的价值持怀疑态度。那些做出优秀工作的人常常认为他们正在做的事情并不好。"
    },
    {
      "original": "Others see what they've done and are full of wonder, but the creator is full of worry. This pattern is no coincidence: it is the worry that made the work good.If you can keep hope and worry balanced, they will drive a project forward the same way your two legs drive a bicycle forward.",
      "translated": "其他人看到他们的作品时充满惊叹，但创作者却满心忧虑。这种模式并非偶然：正是这种忧虑使得作品更加出色。如果你能保持希望和忧虑的平衡，它们就会像你骑自行车时的两条腿一样，推动项目向前发展。"
    },
    {
      "original": "In the first phase of the two-cycle innovation engine, you work furiously on some problem, inspired by your confidence that you'll be able to solve it. In the second phase, you look at what you've done in the cold light of morning, and see all its flaws very clearly.",
      "translated": "在两阶段创新引擎的第一个阶段，你充满信心地奋力解决某个问题，相信自己能够找到解决办法。在第二个阶段，你以清晨冷静的头脑审视自己的工作，清晰地看到所有的问题。"
    },
    {
      "original": "But as long as your critical spirit doesn't outweigh your hope, you'll be able to look at your admittedly incomplete system, and think, how hard can it be to get the rest of the way?, thereby continuing the cycle.It's tricky to keep the two forces balanced.",
      "translated": "但只要你的批判精神没有超过你的希望，你就能看着你那承认尚不完整的系统，心想，剩下的路能有多难呢？从而继续这个循环。保持这两种力量的平衡是微妙的。"
    },
    {
      "original": "In young hackers, optimism predominates. They produce something, are convinced it's great, and never improve it. In old hackers, skepticism predominates, and they won't even dare to take on ambitious projects.Anything you can do to keep the redesign cycle going is good.",
      "translated": "在年轻的黑客中，乐观主义占主导。他们创造出一些东西，坚信它是伟大的，而从不改进它。在年老的黑客中，怀疑主义占主导，他们甚至不敢承担雄心勃勃的项目。任何能促使设计迭代持续进行的做法都是好的。"
    },
    {
      "original": "Prose can be rewritten over and over until you're happy with it. But software, as a rule, doesn't get redesigned enough. Prose has readers, but software has users. If a writer rewrites an essay, people who read the old version are unlikely to complain that their thoughts have been broken by some newly introduced incompatibility.Users are a double-edged sword.",
      "translated": "散文可以一遍又一遍地重写，直到你满意为止。但软件通常却得不到足够的重新设计。散文有读者，而软件有用户。如果一位作者重写了一篇文章，读过旧版本的人不太可能抱怨他们的思维被某些新引入的不兼容性打断。用户是一把双刃剑。"
    },
    {
      "original": "They can help you improve your language, but they can also deter you from improving it. So choose your users carefully, and be slow to grow their number. Having users is like optimization: the wise course is to delay it.",
      "translated": "他们可以帮助你提高语言水平，但也可能阻碍你的进步。因此，要谨慎选择用户，并缓慢增加用户数量。拥有用户就像优化一样：明智的做法是延迟进行。"
    },
    {
      "original": "Also, as a general rule, you can at any given time get away with changing more than you think. Introducing change is like pulling off a bandage: the pain is a memory almost as soon as you feel it.Everyone knows that it's not a good idea to have a language designed by a committee.",
      "translated": "另外，一般来说，在任何时候，你可以改变的比你想象的要多。引入变化就像撕掉创可贴：疼痛几乎在你感觉到的同时就成为了记忆。众所周知，由委员会设计的语言并不是个好主意。"
    },
    {
      "original": "Committees yield bad design. But I think the worst danger of committees is that they interfere with redesign. It is so much work to introduce changes that no one wants to bother. Whatever a committee decides tends to stay that way, even if most of the members don't like it.Even a committee of two gets in the way of redesign.",
      "translated": "委员会产生糟糕的设计。但我觉得委员会最危险的地方在于它们阻碍了重新设计。引入变更需要做大量的工作，以至于没有人愿意费这个劲。无论委员会作出什么决定，都会保持原样，即使大多数成员都不喜欢。即使是两个人的委员会也会妨碍重新设计。"
    },
    {
      "original": "This happens particularly in the interfaces between pieces of software written by two different people. To change the interface both have to agree to change it at once. And so interfaces tend not to change at all, which is a problem because they tend to be one of the most ad hoc parts of any system.One solution here might be to design systems so that interfaces are horizontal instead of vertical — so that modules are always vertically stacked strata of abstraction.",
      "translated": "这尤其发生在由两个人编写的软件组件之间的接口上。要更改接口，双方必须同时同意进行更改。因此，接口往往根本不会改变，这成为一个问题，因为它们往往是任何系统中最随意的部分之一。一个解决方案可能是设计系统，使接口是水平的而不是垂直的——即模块始终是垂直堆叠的抽象层次。"
    },
    {
      "original": "Then the interface will tend to be owned by one of them. The lower of two levels will either be a language in which the upper is written, in which case the lower level will own the interface, or it will be a slave, in which case the interface can be dictated by the upper level.11 LispWhat all this implies is that there is hope for a new Lisp.",
      "translated": "那么，接口将倾向于由其中一方拥有。较低的层级要么是较高层级所用的语言，在这种情况下，较低层级将拥有接口；要么是较低层级作为从属，此时接口可以由较高层级决定。这一切意味着，有一种新型的Lisp语言有望出现。"
    },
    {
      "original": "There is hope for any language that gives hackers what they want, including Lisp. I think we may have made a mistake in thinking that hackers are turned off by Lisp's strangeness. This comforting illusion may have prevented us from seeing the real problem with Lisp, or at least Common Lisp, which is that it sucks for doing what hackers want to do.",
      "translated": "任何能够满足黑客需求的语言都有希望，包括Lisp。我认为我们可能误解了黑客对Lisp古怪之处的反感。这种令人安慰的错觉可能阻止了我们看到Lisp，至少是Common Lisp，存在的真正问题，即它在实现黑客想要做的事情时表现得很差。"
    },
    {
      "original": "A hacker's language needs powerful libraries and something to hack. Common Lisp has neither. A hacker's language is terse and hackable. Common Lisp is not.The good news is, it's not Lisp that sucks, but Common Lisp.",
      "translated": "黑客的语言需要强大的库和可以破解的东西。Common Lisp 两者都不具备。黑客的语言简洁且易于破解。Common Lisp 却不是这样。好消息是，问题不在于 Lisp，而在于 Common Lisp。"
    },
    {
      "original": "If we can develop a new Lisp that is a real hacker's language, I think hackers will use it. They will use whatever language does the job. All we have to do is make sure this new Lisp does some important job better than other languages.History offers some encouragement.",
      "translated": "如果我们能够开发出一种真正适合黑客的新Lisp语言，我相信黑客们会使用它。他们会使用任何能够完成任务的语言。我们只需要确保这种新的Lisp语言在某些重要方面比其他语言做得更好。历史为我们提供了某些鼓励。"
    },
    {
      "original": "Over time, successive new programming languages have taken more and more features from Lisp. There is no longer much left to copy before the language you've made is Lisp. The latest hot language, Python, is a watered-down Lisp with infix syntax and no macros.",
      "translated": "随着时间的推移，新一代的编程语言越来越多地借鉴了Lisp的特点。在你所创造的语言中，剩下的可借鉴之处已经不多了，再借鉴就几乎成了Lisp。最新的热门语言，Python，可以看作是简化版的Lisp，采用了中缀语法并且没有宏。"
    },
    {
      "original": "A new Lisp would be a natural step in this progression.I sometimes think that it would be a good marketing trick to call it an improved version of Python. That sounds hipper than Lisp. To many people, Lisp is a slow AI language with a lot of parentheses.",
      "translated": "推出一种新的Lisp语言将是这一进程中的自然一步。我有时认为，将其称为Python的改进版本会是一个不错的营销策略。这听起来比Lisp更时尚。对许多人来说，Lisp是一种带有大量括号的缓慢的AI语言。"
    },
    {
      "original": "Fritz Kunze's official biography carefully avoids mentioning the L-word. But my guess is that we shouldn't be afraid to call the new Lisp Lisp. Lisp still has a lot of latent respect among the very best hackers — the ones who took 6.001 and understood it, for example.",
      "translated": "弗里茨·昆泽的官方传记刻意避免提到L字。但我猜测，我们不应该害怕将新的Lisp称为Lisp。Lisp在最顶尖的黑客中仍享有很高的潜在尊重——比如那些修读过6.001课程并理解了它的人。"
    },
    {
      "original": "And those are the users you need to win.In \"How to Become a Hacker,\" Eric Raymond describes Lisp as something like Latin or Greek — a language you should learn as an intellectual exercise, even though you won't actually use it: Lisp is worth learning for the profound enlightenment experience you will have when you finally get it; that experience will make you a better programmer for the rest of your days, even if you never actually use Lisp itself a lot.",
      "translated": "这些就是你需要争取的用户。在《如何成为一名黑客》中，Eric Raymond 将 Lisp 描述为类似拉丁语或希腊语的东西——一种你应该为了智力锻炼而学习的语言，即使你实际上不会使用它：Lisp 值得学习，因为当你最终理解它时，会有一种深刻的启迪体验；这种体验将使你在余生中成为一个更好的程序员，即使你从未大量使用过 Lisp 本身。"
    },
    {
      "original": "If I didn't know Lisp, reading this would set me asking questions. A language that would make me a better programmer, if it means anything at all, means a language that would be better for programming.",
      "translated": "如果我不懂Lisp，读了这段文字肯定会让我产生疑问。一种能让我成为更好的程序员的语言，如果它有意义的话，意味着一种更适合编程的语言。"
    },
    {
      "original": "And that is in fact the implication of what Eric is saying.As long as that idea is still floating around, I think hackers will be receptive enough to a new Lisp, even if it is called Lisp. But this Lisp must be a hacker's language, like the classic Lisps of the 1970s.",
      "translated": "这实际上就是埃里克所说的话的含义。只要这种想法还在流传，我认为黑客们会对一种新的Lisp语言保持足够的兴趣，即使它仍然被称为Lisp。但这种Lisp必须是一种黑客的语言，就像20世纪70年代的经典Lisp一样。"
    },
    {
      "original": "It must be terse, simple, and hackable. And it must have powerful libraries for doing what hackers want to do now.In the matter of libraries I think there is room to beat languages like Perl and Python at their own game.",
      "translated": "它必须简洁、简单且易于黑客操作。同时，它必须拥有强大的库，以满足黑客现在想要做的事情。在库的问题上，我认为有足够的空间可以在这类语言如Perl和Python擅长的领域超越它们。"
    },
    {
      "original": "A lot of the new applications that will need to be written in the coming years will be server-based applications. There's no reason a new Lisp shouldn't have string libraries as good as Perl, and if this new Lisp also had powerful libraries for server-based applications, it could be very popular.",
      "translated": "未来几年需要编写的新应用程序中，很多将是基于服务器的应用程序。没有理由新的 Lisp 不能拥有与 Perl 一样优秀的字符串库，如果这种新的 Lisp 还拥有强大的基于服务器的应用程序库，它可能会非常流行。"
    },
    {
      "original": "Real hackers won't turn up their noses at a new tool that will let them solve hard problems with a few library calls. Remember, hackers are lazy.It could be an even bigger win to have core language support for server-based applications.",
      "translated": "真正的黑客不会对能让他们通过几个库调用来解决难题的新工具不屑一顾。记住，黑客是懒惰的。如果核心语言能支持基于服务器的应用程序，那可能会是一个更大的胜利。"
    },
    {
      "original": "For example, explicit support for programs with multiple users, or data ownership at the level of type tags.Server-based applications also give us the answer to the question of what this new Lisp will be used to hack.",
      "translated": "例如，显式支持多用户程序，或在类型标签级别上的数据所有权。基于服务器的应用程序也为我们解答了这个新的Lisp将被用来破解什么问题。"
    },
    {
      "original": "It would not hurt to make Lisp better as a scripting language for Unix. (It would be hard to make it worse.) But I think there are areas where existing languages would be easier to beat. I think it might be better to follow the model of Tcl, and supply the Lisp together with a complete system for supporting server-based applications.",
      "translated": "将Lisp改进为Unix的脚本语言并不会有什么坏处。（让它变得更糟可不容易。）但我觉得在某些领域，现有的语言更容易被超越。我认为，或许更好的做法是效仿Tcl的模式，提供一个完整的系统来支持基于服务器的应用程序，同时附带Lisp。"
    },
    {
      "original": "Lisp is a natural fit for server-based applications. Lexical closures provide a way to get the effect of subroutines when the ui is just a series of web pages. S-expressions map nicely onto html, and macros are good at generating it.",
      "translated": "Lisp 天然适合基于服务器的应用程序。词法闭包提供了一种在用户界面仅是一系列网页时实现子例程效果的方法。S-表达式与 HTML 非常契合，而宏在生成 HTML 时非常有用。"
    },
    {
      "original": "There need to be better tools for writing server-based applications, and there needs to be a new Lisp, and the two would work very well together.12 The Dream LanguageBy way of summary, let's try describing the hacker's dream language.",
      "translated": "需要有更强大的工具来编写基于服务器的应用程序，同时也需要有一种新的 Lisp，而这两种工具结合起来将会非常完美。通过总结，让我们尝试描述一下黑客梦想中的编程语言。"
    },
    {
      "original": "The dream language is beautiful, clean, and terse. It has an interactive toplevel that starts up fast. You can write programs to solve common problems with very little code. Nearly all the code in any program you write is code that's specific to your application.",
      "translated": "梦语言优美、简洁且精炼。它有一个快速启动的交互式顶层环境。你可以用很少的代码编写程序来解决常见问题。你编写的所有程序中几乎所有的代码都是特定于你的应用程序的。"
    },
    {
      "original": "Everything else has been done for you.The syntax of the language is brief to a fault. You never have to type an unnecessary character, or even to use the shift key much.Using big abstractions you can write the first version of a program very quickly.",
      "translated": "其他的一切都已为你准备好了。这种语言的语法简洁到极致，你永远不会需要多输入一个不必要的字符，甚至几乎不需要使用大写键。通过使用大型抽象，你可以非常迅速地编写出程序的首个版本。"
    },
    {
      "original": "Later, when you want to optimize, there's a really good profiler that tells you where to focus your attention. You can make inner loops blindingly fast, even writing inline byte code if you need to.There are lots of good examples to learn from, and the language is intuitive enough that you can learn how to use it from examples in a couple minutes.",
      "translated": "后来，当你想要优化时，有一个非常棒的分析器可以告诉你应该把注意力集中在哪些地方。你可以让内循环变得极其快速，甚至可以在需要时编写内联字节码。有很多好的例子可以学习，而且这种语言足够直观，你可以在几分钟内通过示例学会如何使用它。"
    },
    {
      "original": "You don't need to look in the manual much. The manual is thin, and has few warnings and qualifications.The language has a small core, and powerful, highly orthogonal libraries that are as carefully designed as the core language.",
      "translated": "你不需要经常查阅手册。手册很薄，警告和注意事项也很少。这门语言的核心很小，但拥有强大且高度正交的库，这些库的设计与核心语言一样精心。"
    },
    {
      "original": "The libraries all work well together; everything in the language fits together like the parts in a fine camera. Nothing is deprecated, or retained for compatibility. The source code of all the libraries is readily available.",
      "translated": "这些库都能很好地协同工作；语言中的所有部分就像精良相机的组件一样紧密配合。没有任何内容被弃用，也没有为了兼容性而保留的内容。所有库的源代码都很容易获得。"
    },
    {
      "original": "It's easy to talk to the operating system and to applications written in other languages.The language is built in layers. The higher-level abstractions are built in a very transparent way out of lower-level abstractions, which you can get hold of if you want.Nothing is hidden from you that doesn't absolutely have to be.",
      "translated": "与操作系统和其他语言编写的应用程序进行通信很容易。这种语言是分层构建的。高层次的抽象是以非常透明的方式从低层次的抽象构建出来的，如果你愿意，可以掌握这些低层次的抽象。除非绝对必要，否则没有任何东西会被隐藏起来。"
    },
    {
      "original": "The language offers abstractions only as a way of saving you work, rather than as a way of telling you what to do. In fact, the language encourages you to be an equal participant in its design. You can change everything about it, including even its syntax, and anything you write has, as much as possible, the same status as what comes predefined.Notes[1] Macros very close to the modern idea were proposed by Timothy Hart in 1964, two years after Lisp 1.5 was released.",
      "translated": "该语言提供的抽象仅是为了节省你的工作，而不是告诉你该怎么做。事实上，这种语言鼓励你成为其设计的平等参与者。你可以改变它的一切，包括其语法，而你编写的内容，尽可能地，具有与预定义内容相同的的地位。注[1] 1964年，蒂莫西·哈特提出了与现代宏非常接近的概念，这比Lisp 1.5发布晚了两年。"
    },
    {
      "original": "What was missing, initially, were ways to avoid variable capture and multiple evaluation; Hart's examples are subject to both.[2] In When the Air Hits Your Brain, neurosurgeon Frank Vertosick recounts a conversation in which his chief resident, Gary, talks about the difference between surgeons and internists (\"fleas\"): Gary and I ordered a large pizza and found an open booth.",
      "translated": "最初缺失的是避免变量捕获和多次求值的方法；Hart 的例子同时存在这两个问题。在《When the Air Hits Your Brain》一书中，神经外科医生 Frank Vertosick 回忆了一段对话，其中他的总住院医师 Gary 谈到了外科医生和内科医生（“跳蚤”）之间的区别：Gary 和我点了一个大比萨，并找到了一个空的卡座。"
    },
    {
      "original": "The chief lit a cigarette. \"Look at those goddamn fleas, jabbering about some disease they'll see once in their lifetimes. That's the trouble with fleas, they only like the bizarre stuff. They hate their bread and butter cases.",
      "translated": "首领点燃了一根香烟。“看看那些该死的跳蚤，叽叽喳喳地讨论他们一生只能遇到一次的疾病。这就是跳蚤的麻烦，他们只对奇异的事物感兴趣。他们讨厌他们的日常案例。”"
    },
    {
      "original": "That's the difference between us and the fucking fleas. See, we love big juicy lumbar disc herniations, but they hate hypertension....\" It's hard to think of a lumbar disc herniation as juicy (except literally).",
      "translated": "这就是我们和那些该死的跳蚤的区别。你看，我们喜欢大的、多汁的腰椎间盘突出，而它们却讨厌高血压……”很难把腰椎间盘突出想象成多汁的（除非是字面上的意义）。"
    },
    {
      "original": "And yet I think I know what they mean. I've often had a juicy bug to track down. Someone who's not a programmer would find it hard to imagine that there could be pleasure in a bug. Surely it's better if everything just works.",
      "translated": "但我认为我明白他们的意思。我经常需要追踪一些棘手的漏洞。对于非程序员来说，很难想象在漏洞中寻找乐趣。当然，如果一切都能正常运作会更好。"
    },
    {
      "original": "In one way, it is. And yet there is undeniably a grim satisfaction in hunting down certain sorts of bugs.Postscript VersionArcFive Questions about Language DesignHow to Become a HackerJapanese Translation",
      "translated": "从某种意义上说，确实如此。然而，追捕某些类型的错误无疑会带来一种冷酷的满足感。附录版本ArcFive 关于语言设计的五个问题如何成为一名黑客日语翻译"
    }
  ],
  "translation_completed": "2025-07-27T13:30:20.476432",
  "translation_stats": {
    "total_paragraphs": 154,
    "success_count": 154,
    "success_rate": "100.0%"
  }
}